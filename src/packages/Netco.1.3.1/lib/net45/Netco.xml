<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Netco</name>
    </assembly>
    <members>
        <member name="T:Netco.ActionPolicyServices.ActionPolicy">
            <summary>
            Policy that could be applied to delegates to
            augment their behavior (i.e. to retry on problems)
            </summary>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicy.#ctor(System.Action{System.Action})">
            <summary>
            Initializes a new instance of the <see cref="T:Netco.ActionPolicyServices.ActionPolicy"/> class.
            </summary>
            <param name="policy">The policy.</param>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicy.Do(System.Action)">
            <summary>
            Performs the specified action within the policy.
            </summary>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicy.Get``1(System.Func{``0})">
            <summary>
            Performs the specified action within the policy and returns the result
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="action">The action to perform.</param>
            <returns>result returned by <paramref name="action"/></returns>
        </member>
        <member name="F:Netco.ActionPolicyServices.ActionPolicy.Null">
            <summary>
            Action policy that does not do anything
            </summary>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicy.With(Netco.ActionPolicyServices.ExceptionHandler)">
            <summary> Starts building <see cref="T:Netco.ActionPolicyServices.ActionPolicy"/> 
            that can handle exceptions, as determined by 
            <paramref name="handler"/> </summary>
            <param name="handler">The exception handler.</param>
            <returns>syntax</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicy.From(System.Func{System.Exception,System.Boolean})">
            <summary> Starts building <see cref="T:Netco.ActionPolicyServices.ActionPolicy"/> 
            that can handle exceptions, as determined by 
            <paramref name="doWeHandle"/> function</summary>
            <param name="doWeHandle"> function that returns <em>true</em> if we can hande the specified exception.</param>
            <returns>syntax</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicy.Handle``1">
            <summary> Starts building simple <see cref="T:Netco.ActionPolicyServices.ActionPolicy"/>
            that can handle <typeparamref name="TException"/> </summary>
            <typeparam name="TException">The type of the exception to handle.</typeparam>
            <returns>syntax</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicy.Handle``2">
            <summary> Starts building simple <see cref="T:Netco.ActionPolicyServices.ActionPolicy"/>
            that can handle <typeparamref name="TEx1"/> or <typeparamref name="TEx1"/>
            </summary>
            <typeparam name="TEx1">The type of the exception to handle.</typeparam>
            <typeparam name="TEx2">The type of the exception to handle.</typeparam>
            <returns>syntax</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicy.Handle``3">
            <summary> Starts building simple <see cref="T:Netco.ActionPolicyServices.ActionPolicy"/>
            that can handle <typeparamref name="TEx1"/> or <typeparamref name="TEx1"/>
            </summary>
            <typeparam name="TEx1">The first type of the exception to handle.</typeparam>
            <typeparam name="TEx2">The second of the exception to handle.</typeparam>
            <typeparam name="TEx3">The third of the exception to handle.</typeparam>
            <returns>syntax</returns>
        </member>
        <member name="T:Netco.ActionPolicyServices.ActionPolicyWithStateAsync">
            <summary>
            Same as <see cref="T:Netco.ActionPolicyServices.ActionPolicy"/>, but indicates that this policy
            holds some state and thus must have syncronized access.
            </summary>
        </member>
        <member name="T:Netco.ActionPolicyServices.ActionPolicyAsync">
            <summary>
            Policy that could be applied to delegates to
            augment their behavior (i.e. to retry on problems)
            </summary>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicyAsync.#ctor(System.Func{System.Func{System.Threading.Tasks.Task},System.Threading.Tasks.Task})">
            <summary>
            Initializes a new instance of the <see cref="T:Netco.ActionPolicyServices.ActionPolicyAsync"/> class.
            </summary>
            <param name="policy">The policy.</param>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicyAsync.Do(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Performs the specified action within the policy.
            </summary>
            <param name="action">The action to perform.</param>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicyAsync.Get``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Performs the specified action within the policy and returns the result
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="action">The action to perform.</param>
            <returns>result returned by <paramref name="action"/></returns>
        </member>
        <member name="F:Netco.ActionPolicyServices.ActionPolicyAsync.Null">
            <summary>
            Action policy that does not do anything
            </summary>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicyAsync.With(Netco.ActionPolicyServices.ExceptionHandler)">
            <summary> Starts building <see cref="T:Netco.ActionPolicyServices.ActionPolicyAsync"/> 
            that can handle exceptions, as determined by 
            <paramref name="handler"/> </summary>
            <param name="handler">The exception handler.</param>
            <returns>syntax</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicyAsync.From(System.Func{System.Exception,System.Boolean})">
            <summary> Starts building <see cref="T:Netco.ActionPolicyServices.ActionPolicyAsync"/> 
            that can handle exceptions, as determined by 
            <paramref name="doWeHandle"/> function</summary>
            <param name="doWeHandle"> function that returns <em>true</em> if we can hande the specified exception.</param>
            <returns>syntax</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicyAsync.Handle``1">
            <summary> Starts building simple <see cref="T:Netco.ActionPolicyServices.ActionPolicyAsync"/>
            that can handle <typeparamref name="TException"/> </summary>
            <typeparam name="TException">The type of the exception to handle.</typeparam>
            <returns>syntax</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicyAsync.Handle``2">
            <summary> Starts building simple <see cref="T:Netco.ActionPolicyServices.ActionPolicyAsync"/>
            that can handle <typeparamref name="TEx1"/> or <typeparamref name="TEx1"/>
            </summary>
            <typeparam name="TEx1">The type of the exception to handle.</typeparam>
            <typeparam name="TEx2">The type of the exception to handle.</typeparam>
            <returns>syntax</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicyAsync.Handle``3">
            <summary> Starts building simple <see cref="T:Netco.ActionPolicyServices.ActionPolicyAsync"/>
            that can handle <typeparamref name="TEx1"/> or <typeparamref name="TEx1"/>
            </summary>
            <typeparam name="TEx1">The first type of the exception to handle.</typeparam>
            <typeparam name="TEx2">The second of the exception to handle.</typeparam>
            <typeparam name="TEx3">The third of the exception to handle.</typeparam>
            <returns>syntax</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicyWithStateAsync.#ctor(System.Func{System.Func{System.Threading.Tasks.Task},System.Threading.Tasks.Task})">
            <summary>
            Initializes a new instance of the <see cref="T:Netco.ActionPolicyServices.ActionPolicyWithState"/> class.
            </summary>
            <param name="policy">The policy.</param>
        </member>
        <member name="T:Netco.ActionPolicyServices.ActionPolicyWithState">
            <summary>
            Same as <see cref="T:Netco.ActionPolicyServices.ActionPolicy"/>, but indicates that this policy
            holds some state and thus must have syncronized access.
            </summary>
        </member>
        <member name="M:Netco.ActionPolicyServices.ActionPolicyWithState.#ctor(System.Action{System.Action})">
            <summary>
            Initializes a new instance of the <see cref="T:Netco.ActionPolicyServices.ActionPolicyWithState"/> class.
            </summary>
            <param name="policy">The policy.</param>
        </member>
        <member name="T:Netco.ActionPolicyServices.ExceptionHandlerSyntaxAsync">
            <summary> Fluent API for defining <see cref="T:Netco.ActionPolicyServices.ActionPolicyAsync"/> 
            that allows to handle exceptions. </summary>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntaxAsync.Retry(Netco.Syntaxis.SyntaxAsync{Netco.ActionPolicyServices.ExceptionHandler},System.Int32)">
            <summary>
            Builds <see cref="T:Netco.ActionPolicyServices.ActionPolicyAsync"/> that will retry exception handling
            for a couple of times before giving up.
            </summary>
            <param name="syntax">The syntax.</param>
            <param name="retryCount">The retry count.</param>
            <returns>reusable instance of policy</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntaxAsync.Retry(Netco.Syntaxis.SyntaxAsync{Netco.ActionPolicyServices.ExceptionHandler},System.Int32,System.Action{System.Exception,System.Int32})">
            <summary>
            Builds <see cref="T:Netco.ActionPolicyServices.ActionPolicyAsync"/> that will retry exception handling
            for a couple of times before giving up.
            </summary>
            <param name="syntax">The syntax.</param>
            <param name="retryCount">The retry count.</param>
            <param name="onRetry">The action to perform on retry (i.e.: write to log).
            First parameter is the exception and second one is its number in sequence. </param>
            <returns>reusable policy instance </returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntaxAsync.RetryAsync(Netco.Syntaxis.SyntaxAsync{Netco.ActionPolicyServices.ExceptionHandler},System.Int32,System.Func{System.Exception,System.Int32,System.Threading.Tasks.Task})">
            <summary>
            Builds <see cref="T:Netco.ActionPolicyServices.ActionPolicyAsync"/> that will retry exception handling
            for a couple of times before giving up.
            </summary>
            <param name="syntax">The syntax.</param>
            <param name="retryCount">The retry count.</param>
            <param name="onRetry">The action to perform on retry (i.e.: write to log).
            First parameter is the exception and second one is its number in sequence. </param>
            <returns>reusable policy instance </returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntaxAsync.RetryForever(Netco.Syntaxis.SyntaxAsync{Netco.ActionPolicyServices.ExceptionHandler},System.Action{System.Exception})">
            <summary> Builds <see cref="T:Netco.ActionPolicyServices.ActionPolicyAsync"/> that will keep retrying forever </summary>
            <param name="syntax">The syntax to extend.</param>
            <param name="onRetry">The action to perform when the exception could be retried.</param>
            <returns> reusable instance of policy</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntaxAsync.RetryForeverAsync(Netco.Syntaxis.SyntaxAsync{Netco.ActionPolicyServices.ExceptionHandler},System.Func{System.Exception,System.Threading.Tasks.Task})">
            <summary> Builds <see cref="T:Netco.ActionPolicyServices.ActionPolicyAsync"/> that will keep retrying forever </summary>
            <param name="syntax">The syntax to extend.</param>
            <param name="onRetry">The action to perform when the exception could be retried.</param>
            <returns> reusable instance of policy</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntaxAsync.WaitAndRetry(Netco.Syntaxis.SyntaxAsync{Netco.ActionPolicyServices.ExceptionHandler},System.Collections.Generic.IEnumerable{System.TimeSpan},System.Action{System.Exception,System.TimeSpan})">
            <summary> <para>Builds the policy that will keep retrying as long as 
            the exception could be handled by the <paramref name="syntax"/> being 
            built and <paramref name="sleepDurations"/> is providing the sleep intervals.
            </para>
            </summary>
            <param name="syntax">The syntax.</param>
            <param name="sleepDurations">The sleep durations.</param>
            <param name="onRetry">The action to perform on retry (i.e.: write to log).
            First parameter is the exception and second one is the planned sleep duration. </param>
            <returns>new policy instance</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntaxAsync.WaitAndRetryAsync(Netco.Syntaxis.SyntaxAsync{Netco.ActionPolicyServices.ExceptionHandler},System.Collections.Generic.IEnumerable{System.TimeSpan},System.Func{System.Exception,System.TimeSpan,System.Threading.Tasks.Task})">
            <summary> <para>Builds the policy that will keep retrying as long as 
            the exception could be handled by the <paramref name="syntax"/> being 
            built and <paramref name="sleepDurations"/> is providing the sleep intervals.
            </para>
            </summary>
            <param name="syntax">The syntax.</param>
            <param name="sleepDurations">The sleep durations.</param>
            <param name="onRetry">The action to perform on retry (i.e.: write to log).
            First parameter is the exception and second one is the planned sleep duration. </param>
            <returns>new policy instance</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntaxAsync.WaitAndRetryAsync(Netco.Syntaxis.SyntaxAsync{Netco.ActionPolicyServices.ExceptionHandler},System.Collections.Generic.IEnumerable{System.TimeSpan},System.Func{System.Exception,System.TimeSpan,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Builds the policy that will keep retrying as long as
            the exception could be handled by the <paramref name="syntax" /> being
            built and <paramref name="sleepDurations" /> is providing the sleep intervals.
            </summary>
            <param name="syntax">The syntax.</param>
            <param name="sleepDurations">The sleep durations.</param>
            <param name="onRetry">The action to perform on retry (i.e.: write to log).
            First parameter is the exception and second one is the planned sleep duration.</param>
            <param name="token">The delay cancellation token.</param>
            <returns>
            new policy instance
            </returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntaxAsync.WaitAndRetry(Netco.Syntaxis.SyntaxAsync{Netco.ActionPolicyServices.ExceptionHandler},System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary> <para>Builds the policy that will keep retrying as long as 
            the exception could be handled by the <paramref name="syntax"/> being 
            built and <paramref name="sleepDurations"/> is providing the sleep intervals.
            </para>
            </summary>
            <param name="syntax">The syntax.</param>
            <param name="sleepDurations">The sleep durations.</param>
            <returns>new policy instance</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntaxAsync.WaitAndRetryAsync(Netco.Syntaxis.SyntaxAsync{Netco.ActionPolicyServices.ExceptionHandler},System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary> <para>Builds the policy that will keep retrying as long as 
            the exception could be handled by the <paramref name="syntax"/> being 
            built and <paramref name="sleepDurations"/> is providing the sleep intervals.
            </para>
            </summary>
            <param name="syntax">The syntax.</param>
            <param name="sleepDurations">The sleep durations.</param>
            <returns>new policy instance</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntaxAsync.CircuitBreaker(Netco.Syntaxis.SyntaxAsync{Netco.ActionPolicyServices.ExceptionHandler},System.TimeSpan,System.Int32)">
            <summary>
             <para>Builds the policy that will "break the circuit" after <paramref name="countBeforeBreaking"/>
            exceptions that could be handled by the <paramref name="syntax"/> being built. The circuit 
            stays broken for the <paramref name="duration"/>. Any attempt to
            invoke method within the policy, while the circuit is broken, will immediately re-throw
            the last exception.  </para>
            <para>If the action fails within the policy after the block period, then the breaker 
            is blocked again for the next <paramref name="duration"/>.
            It will be reset, otherwise.</para> 
            </summary>
            <param name="syntax">The syntax.</param>
            <param name="duration">How much time the breaker will stay open before resetting</param>
            <param name="countBeforeBreaking">How many exceptions are needed to break the circuit</param>
            <returns>shared policy instance</returns>
            <remarks>(see "ReleaseIT!" for the details)</remarks>
        </member>
        <member name="T:Netco.ActionPolicyServices.ExceptionHandler">
            <summary> This delegate represents <em>catch</em> block
            </summary>
            <param name="ex">Exception to handle</param>
            <returns><em>true</em> if we can handle exception</returns>
        </member>
        <member name="T:Netco.ActionPolicyServices.ExceptionHandlerSyntax">
            <summary> Fluent API for defining <see cref="T:Netco.ActionPolicyServices.ActionPolicy"/> 
            that allows to handle exceptions. </summary>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntax.Retry(Netco.Syntaxis.Syntax{Netco.ActionPolicyServices.ExceptionHandler},System.Int32)">
            <summary>
            Builds <see cref="T:Netco.ActionPolicyServices.ActionPolicy"/> that will retry exception handling
            for a couple of times before giving up.
            </summary>
            <param name="syntax">The syntax.</param>
            <param name="retryCount">The retry count.</param>
            <returns>reusable instance of policy</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntax.Retry(Netco.Syntaxis.Syntax{Netco.ActionPolicyServices.ExceptionHandler},System.Int32,System.Action{System.Exception,System.Int32})">
            <summary>
            Builds <see cref="T:Netco.ActionPolicyServices.ActionPolicy"/> that will retry exception handling
            for a couple of times before giving up.
            </summary>
            <param name="syntax">The syntax.</param>
            <param name="retryCount">The retry count.</param>
            <param name="onRetry">The action to perform on retry (i.e.: write to log).
            First parameter is the exception and second one is its number in sequence. </param>
            <returns>reusable policy instance </returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntax.RetryForever(Netco.Syntaxis.Syntax{Netco.ActionPolicyServices.ExceptionHandler},System.Action{System.Exception})">
            <summary> Builds <see cref="T:Netco.ActionPolicyServices.ActionPolicy"/> that will keep retrying forever </summary>
            <param name="syntax">The syntax to extend.</param>
            <param name="onRetry">The action to perform when the exception could be retried.</param>
            <returns> reusable instance of policy</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntax.WaitAndRetry(Netco.Syntaxis.Syntax{Netco.ActionPolicyServices.ExceptionHandler},System.Collections.Generic.IEnumerable{System.TimeSpan},System.Action{System.Exception,System.TimeSpan})">
            <summary> <para>Builds the policy that will keep retrying as long as 
            the exception could be handled by the <paramref name="syntax"/> being 
            built and <paramref name="sleepDurations"/> is providing the sleep intervals.
            </para>
            </summary>
            <param name="syntax">The syntax.</param>
            <param name="sleepDurations">The sleep durations.</param>
            <param name="onRetry">The action to perform on retry (i.e.: write to log).
            First parameter is the exception and second one is the planned sleep duration. </param>
            <returns>new policy instance</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntax.WaitAndRetry(Netco.Syntaxis.Syntax{Netco.ActionPolicyServices.ExceptionHandler},System.Collections.Generic.IEnumerable{System.TimeSpan})">
            <summary> <para>Builds the policy that will keep retrying as long as 
            the exception could be handled by the <paramref name="syntax"/> being 
            built and <paramref name="sleepDurations"/> is providing the sleep intervals.
            </para>
            </summary>
            <param name="syntax">The syntax.</param>
            <param name="sleepDurations">The sleep durations.</param>
            <returns>new policy instance</returns>
        </member>
        <member name="M:Netco.ActionPolicyServices.ExceptionHandlerSyntax.CircuitBreaker(Netco.Syntaxis.Syntax{Netco.ActionPolicyServices.ExceptionHandler},System.TimeSpan,System.Int32)">
            <summary>
             <para>Builds the policy that will "break the circuit" after <paramref name="countBeforeBreaking"/>
            exceptions that could be handled by the <paramref name="syntax"/> being built. The circuit 
            stays broken for the <paramref name="duration"/>. Any attempt to
            invoke method within the policy, while the circuit is broken, will immediately re-throw
            the last exception.  </para>
            <para>If the action fails within the policy after the block period, then the breaker 
            is blocked again for the next <paramref name="duration"/>.
            It will be reset, otherwise.</para> 
            </summary>
            <param name="syntax">The syntax.</param>
            <param name="duration">How much time the breaker will stay open before resetting</param>
            <param name="countBeforeBreaking">How many exceptions are needed to break the circuit</param>
            <returns>shared policy instance</returns>
            <remarks>(see "ReleaseIT!" for the details)</remarks>
        </member>
        <member name="T:Netco.Extensions.EnumerablePaginationExtensions">
            <summary>
            Extends enumerables with methods to process collection in pages.
            </summary>
        </member>
        <member name="M:Netco.Extensions.EnumerablePaginationExtensions.ProcessWithPages``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Processes all items within enumerable by breaking it down into pages.
            </summary>
            <typeparam name="TData">The type of the data.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="data">The data.</param>
            <param name="pageSize">Size of the page.</param>
            <param name="processor">The processor (which is passed single page).</param>
            <returns>Result of pages processing.</returns>
            <remarks>All processing is parallelized.</remarks>
        </member>
        <member name="M:Netco.Extensions.EnumerablePaginationExtensions.ProcessWithPagesAsync``2(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{``1}}})">
            <summary>
            Processes all items within enumerable by breaking it down into pages.
            </summary>
            <typeparam name="TData">The type of the data.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="data">The data.</param>
            <param name="pageSize">Size of the page.</param>
            <param name="processor">The async processor (which is passed single page).</param>
            <returns>Result of pages processing.</returns>
        </member>
        <member name="M:Netco.Extensions.EnumerablePaginationExtensions.DoWithPages``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Action{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Acts upon data by breaking it down into separate pages.
            </summary>
            <typeparam name="TData">The type of the data.</typeparam>
            <param name="data">The data.</param>
            <param name="pageSize">Size of the page.</param>
            <param name="pageAction">Action for single page.</param>
        </member>
        <member name="M:Netco.Extensions.EnumerablePaginationExtensions.DoWithPagesAsync``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.Task})">
            <summary>
            Acts upon data by breaking it down into separate pages (async).
            </summary>
            <typeparam name="TData">The type of the data.</typeparam>
            <param name="data">The data.</param>
            <param name="pageSize">Size of the page.</param>
            <param name="pageAction">Async action for single page.</param>
        </member>
        <member name="T:Netco.Syntaxis.SyntaxAsync`1">
            <summary>
            Helper class for creating fluent APIs
            </summary>
            <typeparam name="TTarget">underlying type</typeparam>
            <remarks>Similar to <see cref="T:Netco.Syntaxis.Syntax`1"/> but for use with async methods.</remarks>
        </member>
        <member name="T:Netco.Syntaxis.Syntax">
            <summary>
            Helper class for creating fluent APIs, that hides unused signatures
            </summary>
        </member>
        <member name="M:Netco.Syntaxis.Syntax.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Netco.Syntaxis.Syntax.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Netco.Syntaxis.Syntax.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Netco.Syntaxis.Syntax.GetType">
            <summary>
            Gets the <see cref="T:System.Type"/> of the current instance.
            </summary>
            <returns>
            The <see cref="T:System.Type"/> instance that represents the exact runtime type of the current instance.
            </returns>
        </member>
        <member name="M:Netco.Syntaxis.Syntax.For``1(``0)">
            <summary>
            Creates the syntax for the specified target
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="inner">The inner.</param>
            <returns>new syntax instance</returns>
        </member>
        <member name="M:Netco.Syntaxis.Syntax.ForAsync``1(``0)">
            <summary>
            Creates the syntax for the specified target
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="inner">The inner.</param>
            <returns>new syntax instance</returns>
        </member>
        <member name="T:Netco.Syntaxis.ISyntax`1">
            <summary>
            Interface for implementing decoupled configuration extensions. It hides
            unnecessary members from the IntelliSense.
            </summary>
            <typeparam name="TTarget">syntax target</typeparam>
        </member>
        <member name="M:Netco.Syntaxis.ISyntax`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Netco.Syntaxis.ISyntax`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Netco.Syntaxis.ISyntax`1.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Netco.Syntaxis.ISyntax`1.GetType">
            <summary>
            Gets the <see cref="T:System.Type"/> of the current instance.
            </summary>
            <returns>
            The <see cref="T:System.Type"/> instance that represents the exact runtime type of the current instance.
            </returns>
        </member>
        <member name="P:Netco.Syntaxis.ISyntax`1.Target">
            <summary>
            Gets the underlying object.
            </summary>
            <value>The underlying object.</value>
        </member>
        <member name="M:Netco.Syntaxis.SyntaxAsync`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Netco.Syntaxis.SyntaxAsync`1"/> class.
            </summary>
            <param name="inner">The underlying instance.</param>
        </member>
        <member name="P:Netco.Syntaxis.SyntaxAsync`1.Target">
            <summary>
            Gets the underlying object.
            </summary>
            <value>The underlying object.</value>
        </member>
        <member name="T:Netco.Threading.DisposableAction">
            <summary>
            Class that allows action to be executed, when it is disposed
            </summary>
        </member>
        <member name="M:Netco.Threading.DisposableAction.#ctor(System.Action)">
            <summary>
            Initializes a new instance of the <see cref="T:Netco.Threading.DisposableAction"/> class.
            </summary>
            <param name="action">The action.</param>
        </member>
        <member name="M:Netco.Threading.DisposableAction.Dispose">
            <summary>
            Executes the action
            </summary>
        </member>
        <member name="T:Netco.Extensions.AssemblyExtensions">
            <summary>
            Adds extensions to simplify working with <see cref="T:System.Reflection.Assembly"/>.
            </summary>
        </member>
        <member name="M:Netco.Extensions.AssemblyExtensions.GetOriginalLocation(System.Reflection.Assembly)">
            <summary>
            Gets the original location of an assembly (before it was shadow-copied).
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>Original location of the assembly.</returns>
            <remarks>Original location or <see cref="F:System.String.Empty"/> if location couldn't be determined (because assembly was loaded
            from byte array for example).</remarks>
        </member>
        <member name="T:Netco.Events.OnEvent">
            <summary>
            Simplifies raising events.
            </summary>
        </member>
        <member name="M:Netco.Events.OnEvent.Raise(System.EventHandler,System.Object)">
            <summary>
            Call to raise generic event.
            </summary>
            <param name="eventHandler">The event handler.</param>
            <param name="source">The source.</param>
        </member>
        <member name="M:Netco.Events.OnEvent.Raise``1(System.EventHandler{``0},System.Object,``0)">
            <summary>
            Call to raise event with specific event arguments.
            </summary>
            <typeparam name="T">Event arguments type.</typeparam>
            <param name="eventHandler">The event handler.</param>
            <param name="source">The source.</param>
            <param name="e">The event arguments.</param>
        </member>
        <member name="M:Netco.Events.OnEvent.Raise(System.ComponentModel.PropertyChangedEventHandler,System.Object,System.String)">
            <summary>
            Call to raise event in response to a property being changed.
            </summary>
            <param name="eventHandler">The event handler.</param>
            <param name="source">The source.</param>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="T:Netco.Events.EventArgs`1">
            <summary>
            Generic version of EventArgs to avoid 
            defining custom  EventArgs types 
            </summary>
            <typeparam name="T">Data to pass to event handler.</typeparam>
            <remarks>Based on Ayende's Rhino Commons.</remarks>
        </member>
        <member name="M:Netco.Events.EventArgs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Netco.Events.EventArgs`1"/> class.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="P:Netco.Events.EventArgs`1.Item">
            <summary>
            Gets or sets the item.
            </summary>
            <value>The item.</value>
        </member>
        <member name="T:Netco.Extensions.DateTimeExtensions">
            <summary>
            Provides helper methods for <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:Netco.Extensions.DateTimeExtensions.ToPresetLocal(System.DateTime)">
            <summary>
            Converts <see cref="T:System.DateTime"/> to local time zone.
            </summary>
            <param name="dateTime">The date time.</param>
            <returns>Local <see cref="T:System.DateTime"/>.</returns>
            <remarks>Relies on <see cref="P:Netco.Extensions.DateTimeExtensions.LocalTimeZone"/> for conversion.</remarks>
        </member>
        <member name="M:Netco.Extensions.DateTimeExtensions.SetLocalTimeZone(Netco.Extensions.DateTimeExtensions.CommonTimeZone)">
            <summary>
            Sets the local time zone.
            </summary>
            <param name="timeZone">The time zone.</param>
        </member>
        <member name="P:Netco.Extensions.DateTimeExtensions.LocalTimeZone">
            <summary>
            Gets or sets the local time zone used by <see cref="M:Netco.Extensions.DateTimeExtensions.ToPresetLocal(System.DateTime)"/>.
            </summary>
            <value>The local time zone.</value>
        </member>
        <member name="T:Netco.Extensions.DateTimeExtensions.CommonTimeZone">
            <summary>
            Commonly supported time zones.
            </summary>
            <seealso href="http://www.timeanddate.com/library/abbreviations/timezones/na/"/>
        </member>
        <member name="F:Netco.Extensions.DateTimeExtensions.CommonTimeZone.PST">
            <summary>
            Pacific Standard Time
            </summary>
            <remarks>UTC - 8 hours, EST - 3 hours</remarks>
        </member>
        <member name="F:Netco.Extensions.DateTimeExtensions.CommonTimeZone.MST">
            <summary>
            Mountain Standard Time
            </summary>
            <remarks>UTC - 7 hours, EST - 2 hours, PST + 1 hour</remarks>
        </member>
        <member name="F:Netco.Extensions.DateTimeExtensions.CommonTimeZone.CST">
            <summary>
            Central Standard Time
            </summary>
            <remarks>UTC - 6 hours, EST - 1 hour, PST + 2 hours</remarks>
        </member>
        <member name="F:Netco.Extensions.DateTimeExtensions.CommonTimeZone.EST">
            <summary>
            Eastern Standard Time
            </summary>
            <remarks>UTC - 5 hours, PST + 3 hours</remarks>
        </member>
        <member name="T:Netco.Extensions.EnumerableExtensions">
            <summary>
            Provides extensions for <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Performs the specified <see cref="T:System.Action`1"/> against every element of <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable">Enumerable to extend</param>
            <param name="action">Action to perform; second parameter represents the index</param>
            <exception cref="T:System.ArgumentNullException">When any parameter is null</exception>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Performs the specified <see cref="T:System.Action`1"/> on each element in the source sequence.
            </summary>
            <typeparam name="T">The type of the elements in the sequence</typeparam>
            <param name="enumerable">The sequence of elements</param>
            <param name="action">The action to execute on each element</param>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.FirstOrEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Retrieves first value from the <paramref name="sequence"/>
            </summary>
            <typeparam name="TSource">The type of the source sequence.</typeparam>
            <param name="sequence">The source.</param>
            <param name="predicate">The predicate.</param>
            <returns>first value</returns>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.FirstOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Retrieves first value from the <paramref name="sequence"/>
            </summary>
            <typeparam name="TSource">The type of the source sequence.</typeparam>
            <param name="sequence">The source.</param>
            <returns>first value or empty result, if it is not found</returns>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Applies the specified action to the target <paramref name="enumerable"/>.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable">The enumerable.</param>
            <param name="action">The action to execute against every item.</param>
            <returns>enumerator</returns>
            <exception cref="T:System.ArgumentNullException">when one of the values is null</exception>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Applies the specified action to the target <paramref name="enumerable"/>.
            </summary>
            <typeparam name="TSource">Type of the elements in <paramref name="enumerable"/></typeparam>
            <param name="enumerable">The enumerable.</param>
            <param name="action">The action to execute against every item; second
            parameter represents the index.</param>
            <returns>enumerator</returns>
            <exception cref="T:System.ArgumentNullException">when one of the values is null</exception>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Returns <em>True</em> as soon as the first member of <paramref name="enumerable"/>
            mathes <paramref name="predicate"/>
            </summary>
            <typeparam name="TSource">Type of the elements in <paramref name="enumerable"/></typeparam>
            <param name="enumerable">The enumerable</param>
            <param name="predicate">The predicate.</param>
            <returns>true if the <paramref name="enumerable"/> contains any elements
            matching <paramref name="predicate"/></returns>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.Exists``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks if the provided enumerable has anything
            </summary>
            <typeparam name="TSource">Type of the elements in <paramref name="enumerable"/></typeparam>
            <param name="enumerable">The enumerable.</param>
            <returns>true if the sequence contains any elements</returns>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.ToSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts the enumerable to <see cref="T:System.Collections.Generic.HashSet`1"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="enumerable">The enumerable.</param>
            <returns>hashset instance</returns>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.ToSet``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>
            Converts the enumerable to <see cref="T:System.Collections.Generic.HashSet`1"/>
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="enumerable">The enumerable.</param>
            <param name="selector">The selector.</param>
            <returns>hashset instance</returns>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.Slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,System.Int32},System.Int32)">
            <summary>
            <para>Performs lazy splitting of the provided collection into collections of <paramref name="sliceLength"/>.</para>
            <para>Each collection will have total <em>weight</em> equal or less than <paramref name="maxSliceWeight"/></para>
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="source">The source collection to slice.</param>
            <param name="sliceLength">Length of the slice.</param>
            <param name="weightDelegate">Function to calculate <em>weight</em> of each item in the collection</param>
            <param name="maxSliceWeight">The max item weight.</param>
            <returns>enumerator over the results</returns>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.Slice``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Performs lazy splitting of the provided collection into collections of <paramref name="sliceLength"/>
            </summary>
            <typeparam name="TItem">The type of the item.</typeparam>
            <param name="source">The source.</param>
            <param name="sliceLength">Maximum length of the slice.</param>
            <returns>lazy enumerator of the collection of arrays</returns>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.ToJaggedArray``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Converts collection of collections to jagged array
            </summary>
            <typeparam name="T">type of the items in collection</typeparam>
            <param name="collection">The collection.</param>
            <returns>jagged array</returns>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.ToIndexed``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Applies the integral indexer to the sequence in a lazy manner
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <param name="source">The sequence.</param>
            <returns>indexed sequence</returns>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="source"/> is null</exception>
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.ToIndexDictionary``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Enumerates and returns a mapping that associated the items with their respective
            indices (positions) within the enumeration.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <param name="source">The source.</param>
            <returns>a dictionary</returns>
            <remarks><para>Typical usage is <c>coll.ToIndex()["foo"]</c> that returns
            the position of the item <c>"foo"</c> in the initial collection.</para>
            <para>if multiple similar entries are present in the original collection,
            index of the first entry is recorded.
            </para>
            
            </remarks>
            
        </member>
        <member name="M:Netco.Extensions.EnumerableExtensions.SelectValues``1(System.Collections.Generic.IEnumerable{Netco.Monads.Maybe{``0}})">
            <summary>
            Selects the values from a sequence of optionals.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="sequence">The sequence.</param>
            <returns>enumerable that contains values</returns>
        </member>
        <member name="T:Netco.Extensions.Indexer`1">
            <summary>
            Indexing wrapper that contains value and its integral position.
            </summary>
            <typeparam name="TSource">type of the underlying item</typeparam>
        </member>
        <member name="P:Netco.Extensions.Indexer`1.Index">
            <summary>
            Gets the integral position of the item.
            </summary>
            <value>The integral position of the item.</value>
        </member>
        <member name="P:Netco.Extensions.Indexer`1.IsFirst">
            <summary>
            Gets a value indicating whether this instance is first.
            </summary>
            <value><c>true</c> if this instance is first; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Netco.Extensions.Indexer`1.Value">
            <summary>
            Gets the value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="T:Netco.Extensions.TimeSpanExtensions">
            <summary>
            Extension methods for <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="M:Netco.Extensions.TimeSpanExtensions.ToTimeSpan(System.String)">
            <summary>
            Converts <see cref="T:System.String"/> to <see cref="T:System.TimeSpan"/>.
            </summary>
            <param name="s">The s.</param>
            <returns><see cref="T:System.TimeSpan"/> created from the supplied string.</returns>
            <remarks>Converts "1.5h", "30m", or "1" (default hour) to <see cref="T:System.TimeSpan"/>.</remarks>
        </member>
        <member name="M:Netco.Extensions.TimeSpanExtensions.ToStringFormat(System.TimeSpan)">
            <summary>
            Converts <see cref="T:System.TimeSpan"/> to string.
            </summary>
            <param name="timeSpan">The time span.</param>
            <returns>String representing time span.</returns>
        </member>
        <member name="M:Netco.Extensions.TimeSpanExtensions.ToStringFormat(System.TimeSpan,System.String)">
            <summary>
            Converts <see cref="T:System.TimeSpan"/> to string.
            </summary>
            <param name="timeSpan">The time span.</param>
            <param name="format">The <see cref="M:System.DateTime.ToString(System.String)"/> format.</param>
            <returns>Formatted <see cref="T:System.TimeSpan"/> string.</returns>
            <remarks>If <paramref name="format"/> is <c>null</c> or empty default formatting is used.
            <para>With default formatting if time span is less than an hour, total minutes are shown followed by "m" (<b>15m</b>).
            Otherwise total hours are shown followed by "h" (<b>1.5h</b>).</para></remarks>
        </member>
        <member name="T:Netco.Logging.ConsoleLogger">
            <summary>
            Sends all log messages to the console.
            </summary>
        </member>
        <member name="T:Netco.Logging.ILogger">
            <summary>
            Logger interface to use for logging.
            </summary>
            <remarks>Logging providers are expected to implement this.</remarks>
        </member>
        <member name="M:Netco.Logging.ILogger.Trace(System.String)">
            <summary>
            Logs the trace message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Trace(System.Exception,System.String)">
            <summary>
            Logs the trace message.
            </summary>
            <param name="exception">The exception.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Trace(System.String,System.Object[])">
            <summary>
            Logs the trace message.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">The format arguments.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Trace(System.Exception,System.String,System.Object[])">
            <summary>
            Logs the trace message.
            </summary>
            <param name="exception">The exception.</param>
            <param name="format">The format string.</param>
            <param name="args">The format arguments.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Debug(System.String)">
            <summary>
            Logs the debug message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Debug(System.Exception,System.String)">
            <summary>
            Logs the debug message.
            </summary>
            <param name="exception">The exception.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Debug(System.String,System.Object[])">
            <summary>
            Logs the debug message.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">The format arguments.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Debug(System.Exception,System.String,System.Object[])">
            <summary>
            Logs the debug message.
            </summary>
            <param name="exception">The exception.</param>
            <param name="format">The format string.</param>
            <param name="args">The format arguments.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Info(System.String)">
            <summary>
            Logs the info message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Info(System.Exception,System.String)">
            <summary>
            Logs the info message.
            </summary>
            <param name="exception">The exception.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Info(System.String,System.Object[])">
            <summary>
            Logs the info message.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">The format arguments.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Info(System.Exception,System.String,System.Object[])">
            <summary>
            Logs the info message.
            </summary>
            <param name="exception">The exception.</param>
            <param name="format">The format string.</param>
            <param name="args">The format arguments.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Warn(System.String)">
            <summary>
            Logs the warn message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Warn(System.Exception,System.String)">
            <summary>
            Logs the warn message.
            </summary>
            <param name="exception">The exception.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Warn(System.String,System.Object[])">
            <summary>
            Logs the warn message.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">The format arguments.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Warn(System.Exception,System.String,System.Object[])">
            <summary>
            Logs the warn message.
            </summary>
            <param name="exception">The exception.</param>
            <param name="format">The format string.</param>
            <param name="args">The format arguments.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Error(System.String)">
            <summary>
            Logs the error message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Error(System.Exception,System.String)">
            <summary>
            Logs the error message.
            </summary>
            <param name="exception">The exception.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Error(System.String,System.Object[])">
            <summary>
            Logs the error message.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">The format arguments.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Error(System.Exception,System.String,System.Object[])">
            <summary>
            Logs the error message.
            </summary>
            <param name="exception">The exception.</param>
            <param name="format">The format string.</param>
            <param name="args">The format arguments.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Fatal(System.String)">
            <summary>
            Logs the fatal message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Fatal(System.Exception,System.String)">
            <summary>
            Logs the fatal message.
            </summary>
            <param name="exception">The exception.</param>
            <param name="message">The message.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Fatal(System.String,System.Object[])">
            <summary>
            Logs the fatal message.
            </summary>
            <param name="format">The format string.</param>
            <param name="args">The format arguments.</param>
        </member>
        <member name="M:Netco.Logging.ILogger.Fatal(System.Exception,System.String,System.Object[])">
            <summary>
            Logs the fatal message.
            </summary>
            <param name="exception">The exception.</param>
            <param name="format">The format string.</param>
            <param name="args">The format arguments.</param>
        </member>
        <member name="M:Netco.Logging.ConsoleLogger.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Netco.Logging.ConsoleLogger"/> class.
            </summary>
            <param name="name">The logger name.</param>
        </member>
        <member name="M:Netco.Logging.ConsoleLogger.LM(System.String[])">
            <summary>
            Logs the specified message.
            </summary>
            <param name="messages">All message to log.</param>
        </member>
        <member name="P:Netco.Logging.ConsoleLogger.SeparateLogEntries">
            <summary>
            Gets or sets a value indicating whether to separate log entries.
            </summary>
            <value><c>true</c> if separate log entries with new line; otherwise, <c>false</c>.</value>
            <remarks>When entries are separated, they are easier to read, but take up more space.</remarks>
        </member>
        <member name="T:Netco.Logging.ConsoleLoggerFactory">
            <summary>
            Returns console logger for the specified object type.
            </summary>
        </member>
        <member name="T:Netco.Logging.ILoggerFactory">
            <summary>
            Logger factory interface. Supplies logger for each log call.
            </summary>
            <remarks>Needs to be implemented by each separate logger provider.</remarks>
        </member>
        <member name="M:Netco.Logging.ILoggerFactory.GetLogger(System.Type)">
            <summary>
            Gets the logger to log message for the specified type.
            </summary>
            <param name="objectToLogType">Type of the object to log.</param>
            <returns>Logger to log messages for the specified type.</returns>
        </member>
        <member name="M:Netco.Logging.ILoggerFactory.GetLogger(System.String)">
            <summary>
            Gets the logger to log message for the specified type.
            </summary>
            <param name="loggerName">Name of the logger.</param>
            <returns> Logger to log messages for the specified type.</returns>
        </member>
        <member name="M:Netco.Logging.ConsoleLoggerFactory.GetLogger(System.Type)">
            <summary>
            Gets the logger to log message for the specified type.
            </summary>
            <param name="objectToLogType">Type of the object to log.</param>
            <returns>
            Logger to log messages for the specified type.
            </returns>
        </member>
        <member name="M:Netco.Logging.ConsoleLoggerFactory.GetLogger(System.String)">
            <summary>
            Gets the logger to log message with the specified name.
            </summary>
            <param name="loggerName">The logger name.</param>
            <returns>
            Named logger to log messages.
            </returns>
        </member>
        <member name="P:Netco.Logging.ConsoleLoggerFactory.SeparateLogEntries">
            <summary>
            Gets or sets a value indicating whether to separate log entries.
            </summary>
            <value><c>true</c> if separate log entries with new line; otherwise, <c>false</c>.</value>
            <remarks>When entries are separated, they are easier to read, but take up more space.</remarks>
        </member>
        <member name="T:Netco.Logging.LogExtensions">
            <summary>
            Extends all objects to support logging.
            </summary>
        </member>
        <member name="M:Netco.Logging.LogExtensions.Log``1(``0)">
            <summary>
            Gets the logger for the specified object.
            </summary>
            <typeparam name="T">Type of the object for which to get the logger.</typeparam>
            <param name="needToLogObj">Object to log for.</param>
            <returns>The logger for the specified object.</returns>
        </member>
        <member name="M:Netco.Logging.LogExtensions.Log``1(``0,System.String)">
            <summary>
            Gets the logger with the specified logger name.
            </summary>
            <typeparam name="T">Type of the object for which to get the logger.</typeparam>
            <param name="needToLogObj">Object to log for.</param>
            <param name="loggerName">Name of the logger.</param>
            <returns>The logger with the specified name.</returns>
        </member>
        <member name="T:Netco.Logging.NetcoLogger">
            <summary>
            Provides maing logging support.
            </summary>
        </member>
        <member name="M:Netco.Logging.NetcoLogger.GetLogger(System.Type)">
            <summary>
            Gets the logger.
            </summary>
            <param name="objectToLogType">Type of the object to log.</param>
            <returns>
            Logger to log messages for the specified object type.
            </returns>
        </member>
        <member name="M:Netco.Logging.NetcoLogger.GetLogger(System.String)">
            <summary>
            Gets the logger.
            </summary>
            <param name="loggerName">Name of the logger.</param>
            <returns>
            Logger to log messages for the specified object type.
            </returns>
        </member>
        <member name="P:Netco.Logging.NetcoLogger.LoggerFactory">
            <summary>
            Gets or sets the logger factory.
            </summary>
            <value>
            The logger factory that will supply the logger.
            </value>
        </member>
        <member name="T:Netco.Logging.NullLogger">
            <summary>
            Basic logger that does nothing. No messages will be logged.
            </summary>
        </member>
        <member name="T:Netco.Logging.NullLoggerFactory">
            <summary>
            Returns <see cref="T:Netco.Logging.NullLogger"/> for all object types.
            </summary>
        </member>
        <member name="M:Netco.Logging.NullLoggerFactory.GetLogger(System.Type)">
            <summary>
            Gets the logger to log message for the specified type.
            </summary>
            <param name="objectToLogType">Type of the object to log.</param>
            <returns>
            Logger to log messages for the specified type.
            </returns>
        </member>
        <member name="M:Netco.Logging.NullLoggerFactory.GetLogger(System.String)">
            <summary>
            Gets the logger to log message for the specified type.
            </summary>
            <param name="loggerName">Name of the logger.</param>
            <returns>
            Logger to log messages for the specified type.
            </returns>
        </member>
        <member name="T:Netco.Monads.Maybe`1">
            <summary>
            Helper class that indicates nullable value in a good-citizenship code
            </summary>
            <typeparam name="T">underlying type</typeparam>
        </member>
        <member name="M:Netco.Monads.Maybe`1.GetValue(System.Func{`0})">
            <summary>
            Retrieves value from this instance, using a 
            <paramref name="defaultValue"/> if it is absent.
            </summary>
            <param name="defaultValue">The default value.</param>
            <returns>value</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.GetValue(`0)">
            <summary>
            Retrieves value from this instance, using a 
            <paramref name="defaultValue"/> if it is absent.
            </summary>
            <param name="defaultValue">The default value.</param>
            <returns>value</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.GetValue(System.Func{Netco.Monads.Maybe{`0}})">
            <summary>
            Retrieves value from this instance, using a <paramref name="defaultValue"/>
            factory, if it is absent
            </summary>
            <param name="defaultValue">The default value to provide.</param>
            <returns>maybe value</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.GetValue(Netco.Monads.Maybe{`0})">
            <summary>
            Retrieves value from this instance, using a <paramref name="defaultValue"/>
            if it is absent
            </summary>
            <param name="defaultValue">The default value to provide.</param>
            <returns>maybe value</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.Apply(System.Action{`0})">
            <summary>
            Applies the specified action to the value, if it is present.
            </summary>
            <param name="action">The action.</param>
            <returns>same instance for inlining</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.Apply(System.Action{`0,Netco.Monads.MetaData})">
            <summary>
            Applies the specified action to the value with it's current meta data, if it is present.
            </summary>
            <param name="action">The action.</param>
            <returns>same instance for inlining</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.Handle(System.Action)">
            <summary>
            Executes the specified action, if the value is absent
            </summary>
            <param name="action">The action.</param>
            <returns>same instance for inlining</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.ExposeException(System.Func{System.Exception})">
            <summary>
            Exposes the specified exception if maybe does not have value.
            </summary>
            <param name="exception">The exception.</param>
            <returns>actual value</returns>
            <exception cref="T:System.Exception">if maybe does not have value</exception>
        </member>
        <member name="M:Netco.Monads.Maybe`1.ExposeException(System.String,System.Object[])">
            <summary>
            Throws the exception if maybe does not have value.
            </summary>
            <returns>actual value</returns>
            <exception cref="T:System.InvalidOperationException">if maybe does not have value</exception>
        </member>
        <member name="M:Netco.Monads.Maybe`1.Bind``1(System.Func{`0,Netco.Monads.Maybe{``0}})">
            <summary>
            Binds value to the specified function.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="function">The function to bind to (pipeline funcion).</param>
            <returns>Optional result.</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.Bind``1(System.Func{`0,Netco.Monads.MetaData,Netco.Monads.Maybe{``0}})">
            <summary>
            Binds value to the specified function, providing metadata.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="function">The function to bind to (pipeline funcion).</param>
            <returns>Optional result.</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.Convert``1(System.Func{`0,``0})">
            <summary>
            Converts this instance to <see cref="T:Netco.Monads.Maybe`1"/>, 
            while applying <paramref name="converter"/> if there is a value.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The converter.</param>
            <returns></returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.Convert``1(System.Func{`0,Netco.Monads.MetaData,``0})">
            <summary>
            Converts this instance to <see cref="T:Netco.Monads.Maybe`1"/>, 
            while applying <paramref name="converter"/> if there is a value.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The converter.</param>
            <returns></returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.Convert``1(System.Func{`0,``0},System.Func{``0})">
            <summary>
            Retrieves converted value, using a 
            <paramref name="defaultValue"/> if it is absent.
            </summary>
            <typeparam name="TTarget">type of the conversion target</typeparam>
            <param name="converter">The converter.</param>
            <param name="defaultValue">The default value.</param>
            <returns>value</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.Convert``1(System.Func{`0,Netco.Monads.MetaData,``0},System.Func{``0})">
            <summary>
            Retrieves converted value, using a 
            <paramref name="defaultValue"/> if it is absent.
            </summary>
            <typeparam name="TTarget">type of the conversion target</typeparam>
            <param name="converter">The converter.</param>
            <param name="defaultValue">The default value.</param>
            <returns>value</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.Convert``1(System.Func{`0,``0},``0)">
            <summary>
            Retrieves converted value, using a 
            <paramref name="defaultValue"/> if it is absent.
            </summary>
            <typeparam name="TTarget">type of the conversion target</typeparam>
            <param name="converter">The converter.</param>
            <param name="defaultValue">The default value.</param>
            <returns>value</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.Convert``1(System.Func{`0,Netco.Monads.MetaData,``0},``0)">
            <summary>
            Retrieves converted value, using a 
            <paramref name="defaultValue"/> if it is absent.
            </summary>
            <typeparam name="TTarget">type of the conversion target</typeparam>
            <param name="converter">The converter.</param>
            <param name="defaultValue">The default value.</param>
            <returns>value</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.Equals(Netco.Monads.Maybe{`0})">
            <summary>
            Determines whether the specified <see cref="T:Netco.Monads.Maybe`1"/> is equal to the current <see cref="T:Netco.Monads.Maybe`1"/>.
            </summary>
            <param name="maybe">The <see cref="T:Netco.Monads.Maybe"/> to compare with.</param>
            <returns>true if the objects are equal</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Netco.Monads.Maybe`1.GetHashCode">
            <summary>
            Serves as a hash function for this instance.
            </summary>
            <returns>
            A hash code for the current <see cref="T:Netco.Monads.Maybe`1"/>.
            </returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.op_Equality(Netco.Monads.Maybe{`0},Netco.Monads.Maybe{`0})">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.op_Inequality(Netco.Monads.Maybe{`0},Netco.Monads.Maybe{`0})">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.op_Implicit(`0)~Netco.Monads.Maybe{`0}">
            <summary>
            Performs an implicit conversion from <typeparamref name="T"/> to <see cref="T:Netco.Monads.Maybe`1"/>.
            </summary>
            <param name="item">The item.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.op_Explicit(Netco.Monads.Maybe{`0})~`0">
            <summary>
            Performs an explicit conversion from <see cref="T:Netco.Monads.Maybe`1"/> to <typeparamref name="T"/>.
            </summary>
            <param name="item">The item.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.Join``1(``0)">
            <summary>
            Converts maybe into result, using the specified error as the failure
            descriptor
            </summary>
            <typeparam name="TError">The type of the failure.</typeparam>
            <param name="error">The error.</param>
            <returns>result describing current maybe</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.JoinMessage(System.String)">
            <summary>
            Converts maybe into result, using the specified error as the failure
            descriptor
            </summary>
            <returns>result describing current maybe</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.AddMeta(System.Object,System.Object)">
            <summary>
            Adds the meta data regardless if there's value or not.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns>Current instance for pipe calls.</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.ApplyMeta(System.Object,System.Object)">
            <summary>
            Applies the meta data if there's value.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns>This object for pipe calls.</returns>
        </member>
        <member name="M:Netco.Monads.Maybe`1.GetMeta``1(System.Object)">
            <summary>
            Gets the meta data.
            </summary>
            <typeparam name="TMeta">The type of the meta.</typeparam>
            <param name="metaKey">The meta key.</param>
            <returns>Meta data casted to the specified type.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Specified <paramref name="metaKey"/> key was not found</exception>
        </member>
        <member name="M:Netco.Monads.Maybe`1.TryGetMeta``1(System.Object)">
            <summary>
            Attempts to get meta data.
            </summary>
            <typeparam name="TMeta">The type of the meta.</typeparam>
            <param name="metaKey">The meta key.</param>
            <returns>Maybe with the specified meta data if meta data was found and successfully casted to the specified type.
            Otherwise empty Maybe is returned.</returns>
        </member>
        <member name="P:Netco.Monads.Maybe`1.Empty">
            <summary>
            Default empty instance.
            </summary>
            <remarks>Not static anymore to correctly support meta data for empty maybe.</remarks>
        </member>
        <member name="P:Netco.Monads.Maybe`1.Value">
            <summary>
            Gets the underlying value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="P:Netco.Monads.Maybe`1.HasValue">
            <summary>
            Gets a value indicating whether this instance has value.
            </summary>
            <value><c>true</c> if this instance has value; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Netco.Monads.Maybe`1.HasNothing">
            <summary>
            Gets a value indicating whether this instance has NO value.
            </summary>
            <value><c>true</c> if this instance has NO value; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Netco.Monads.Maybe`1.MetaData">
            <summary>
            Gets the meta data.
            </summary>
        </member>
        <member name="T:Netco.Monads.Maybe">
            <summary>
            Helper routines for <see cref="T:Netco.Monads.Maybe`1"/>
            </summary>
        </member>
        <member name="M:Netco.Monads.Maybe.From``1(``0)">
            <summary>
            Creates new <see cref="T:Netco.Monads.Maybe`1"/> from the provided value
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <param name="item">The item.</param>
            <returns><see cref="T:Netco.Monads.Maybe`1"/> that matches the provided value</returns>
            <exception cref="T:System.ArgumentNullException">if argument is a null reference</exception>
        </member>
        <member name="F:Netco.Monads.Maybe.Bool">
            <summary>
            Optional empty boolean
            </summary>
        </member>
        <member name="F:Netco.Monads.Maybe.String">
            <summary>
            Optional empty string
            </summary>
        </member>
        <member name="T:Netco.Monads.MaybeExtensions">
            <summary>
            Provides extension methods for Maybe monad.
            </summary>
        </member>
        <member name="M:Netco.Monads.MaybeExtensions.SelectMany``2(Netco.Monads.Maybe{``0},System.Func{``0,Netco.Monads.Maybe{``1}})">
            <summary>
            Selects <typeparamref name="TSource"/> using <paramref name="sourceToMaybeResult"/>.
            </summary>
            <typeparam name="TSource">Source type.</typeparam>
            <typeparam name="TResult">Expected result type to wrap in <see cref="T:Netco.Monads.Maybe"/>.</typeparam>
            <param name="source">Source object to select.</param>
            <param name="sourceToMaybeResult">Function to select <paramref name="source"/> in order to get <typeparamref name="TResult"/>.</param>
            <returns><see cref="T:Netco.Monads.Maybe"/> class, possibly with results of the <paramref name="sourceToMaybeResult"/>.</returns>
            <seealso href="http://jystic.com/2009/09/08/whats-with-nullreferenceexceptions-anyway/"/>
        </member>
        <member name="M:Netco.Monads.MaybeExtensions.SelectMany``3(Netco.Monads.Maybe{``0},System.Func{``0,Netco.Monads.Maybe{``1}},System.Func{``0,``1,Netco.Monads.Maybe{``2}})">
            <summary>
            Selects <typeparamref name="TA"/> using <paramref name="aToMaybeB"/> and <paramref name="abToMaybeC"/>.
            </summary>
            <typeparam name="TA">The type of the source.</typeparam>
            <typeparam name="TB">The type of the intermidiate.</typeparam>
            <typeparam name="TC">The type of the result.</typeparam>
            <param name="maybeA">The source.</param>
            <param name="aToMaybeB">The second value selector.</param>
            <param name="abToMaybeC">The result selector.</param>
            <returns><see cref="T:Netco.Monads.Maybe"/> class, possibly with results of the <paramref name="abToMaybeC"/>.</returns>
            <remarks>Required to use LINQ for selection.</remarks>
            <example>
            var packagedSalad = from apple in PickApple()
            from orange in PickOrange()
            from fruitSalad in MakeFruitSalad(apple, orange)
            select PackageForSale(fruitSalad);
            </example>
        </member>
        <member name="M:Netco.Monads.MaybeExtensions.TryGetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Gets the value associated  with the specified key.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="dictionary">The dictionary.</param>
            <param name="key">The key.</param>
            <returns><see cref="T:Netco.Monads.Maybe`1"/> with the result, or empty <see cref="T:Netco.Monads.Maybe`1"/> if there's no object in the dictionary
            with the specified key.</returns>
        </member>
        <member name="T:Netco.Monads.MaybeParse">
            <summary>
            	Helper routines for converting strings into Maybe
            </summary>
        </member>
        <member name="M:Netco.Monads.MaybeParse.Enum``1(System.String)">
            <summary>
            	Tries to parse the specified string into the enum, returning empty result
            	on failure. We ignore case in this scenario.
            </summary>
            <typeparam name="TEnum">
            	The type of the enum.
            </typeparam>
            <param name="value">The value.</param>
            <returns>
            	either enum or an empty result
            </returns>
        </member>
        <member name="M:Netco.Monads.MaybeParse.Enum``1(System.String,System.Boolean)">
            <summary>
            	Tries to parse the specified string into the enum, returning empty result
            	on failure
            </summary>
            <typeparam name="TEnum">
            	The type of the enum.
            </typeparam>
            <param name="value">The value.</param>
            <param name="ignoreCase">
            	if set to
            	<c>true</c>
            	then parsing will ignore case.
            </param>
            <returns>
            	either enum or an empty result
            </returns>
        </member>
        <member name="M:Netco.Monads.MaybeParse.Decimal(System.String)">
            <summary>
            	Tries to parse the specified value into Decimal, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Decimal or an empty result
            </returns>
            <seealso cref="M:System.Decimal.TryParse(System.String,System.Decimal@)"/>
        </member>
        <member name="M:Netco.Monads.MaybeParse.Decimal(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            	Tries to parse the specified value into decimal, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <param name="numberStyles">
            	The number styles to use.
            </param>
            <param name="formatProvider">
            	The format provider to use.
            </param>
            <returns>
            	either parsed decimal or an empty result
            </returns>
            <seealso cref="M:System.Decimal.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Decimal@)"/>
        </member>
        <member name="M:Netco.Monads.MaybeParse.DecimalInvariant(System.String)">
            <summary>
            	Tries to parse the specified value into decimal, using the invariant culture
            	info and returning	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed decimal or an empty result
            </returns>
        </member>
        <member name="M:Netco.Monads.MaybeParse.Int32(System.String)">
            <summary>
            	Tries to parse the specified value into Int32, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Int32 or an empty result
            </returns>
            <seealso cref="M:System.Int32.TryParse(System.String,System.Int32@)"/>
        </member>
        <member name="M:Netco.Monads.MaybeParse.Int32(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            	Tries to parse the specified value into Int32, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <param name="numberStyles">
            	The number styles to use.
            </param>
            <param name="formatProvider">
            	The format provider to use.
            </param>
            <returns>
            	either parsed Int32 or an empty result
            </returns>
            <seealso cref="M:System.Int32.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int32@)"/>
        </member>
        <member name="M:Netco.Monads.MaybeParse.Int32Invariant(System.String)">
            <summary>
            	Tries to parse the specified string value into Int32, 
            	using an invariant culture and returning empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Int32 or an empty result
            </returns>
            <seealso cref="M:System.Int32.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int32@)"/>
        </member>
        <member name="M:Netco.Monads.MaybeParse.Int64(System.String)">
            <summary>
            	Tries to parse the specified value into Int64, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Int64 or an empty result
            </returns>
            <seealso cref="M:System.Int64.TryParse(System.String,System.Int64@)"/>
        </member>
        <member name="M:Netco.Monads.MaybeParse.Int64(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            	Tries to parse the specified value into Int64, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <param name="numberStyles">
            	The number styles to use.
            </param>
            <param name="formatProvider">
            	The format provider to use.
            </param>
            <returns>
            	either parsed Int64 or an empty result
            </returns>
            <seealso cref="M:System.Int64.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int64@)"/>
        </member>
        <member name="M:Netco.Monads.MaybeParse.Int64Invariant(System.String)">
            <summary>
            	Tries to parse the specified string value into Int64, 
            	using an invariant culture and returning empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Int64 or an empty result
            </returns>
            <seealso cref="M:System.Int64.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int64@)"/>
        </member>
        <member name="M:Netco.Monads.MaybeParse.Double(System.String)">
            <summary>
            	Tries to parse the specified value into Double, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Double or an empty result
            </returns>
            <seealso cref="M:System.Double.TryParse(System.String,System.Double@)"/>
        </member>
        <member name="M:Netco.Monads.MaybeParse.Double(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            	Tries to parse the specified value into Double, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <param name="numberStyles">
            	The number styles to use.
            </param>
            <param name="formatProvider">
            	The format provider to use.
            </param>
            <returns>
            	either parsed Double or an empty result
            </returns>
            <seealso cref="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)"/>
        </member>
        <member name="M:Netco.Monads.MaybeParse.DoubleInvariant(System.String)">
            <summary>
            	Attempts to parse the specified value into Double, 
            	using invariant culture and returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Double or an empty result
            </returns>
            <seealso cref="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)"/>
        </member>
        <member name="M:Netco.Monads.MaybeParse.Single(System.String)">
            <summary>
            	Tries to parse the specified value into Single, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Single or an empty result
            </returns>
            <seealso cref="M:System.Single.TryParse(System.String,System.Single@)"/>
        </member>
        <member name="M:Netco.Monads.MaybeParse.Single(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            	Tries to parse the specified value into Single, returning
            	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <param name="numberStyles">
            	The number styles to use.
            </param>
            <param name="formatProvider">
            	The format provider to use.
            </param>
            <returns>
            	either parsed Single or an empty result
            </returns>
            <seealso cref="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)"/>
        </member>
        <member name="M:Netco.Monads.MaybeParse.SingleInvariant(System.String)">
            <summary>
            	Tries to parse the specified value into Single, using invariant culture
            	and returning 	empty result on failure.
            </summary>
            <param name="value">The value.</param>
            <returns>
            	either parsed Single or an empty result
            </returns>
            <seealso cref="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)"/>
        </member>
        <member name="T:Netco.Monads.MetaData">
            <summary>
            Represents meta data.
            </summary>
        </member>
        <member name="M:Netco.Monads.MetaData.GetValue``1(System.Object)">
            <summary>
            Gets the meta data.
            </summary>
            <typeparam name="TMetaValue">The type of the meta.</typeparam>
            <param name="metaKey">The meta key.</param>
            <returns>Meta data casted to the specified type.</returns>
        </member>
        <member name="M:Netco.Monads.MetaData.TryGetValue``1(System.Object)">
            <summary>
            Attempts to get meta data.
            </summary>
            <typeparam name="TMetaValue">The type of the meta.</typeparam>
            <param name="metaKey">The meta key.</param>
            <returns>Maybe with the specified meta data if meta data was found and successfully casted to the specified type.
            Otherwise empty Maybe is returned.</returns>
        </member>
        <member name="P:Netco.Monads.MetaData.Item(System.Object)">
            <summary>
            Gets or sets the <see cref="T:System.Object"/> with the specified meta key.
            </summary>
        </member>
        <member name="T:Netco.Monads.Result`1">
            <summary>
            Helper class that allows to pass out method call results without using exceptions
            </summary>
            <typeparam name="T">type of the associated data</typeparam>
        </member>
        <member name="M:Netco.Monads.Result`1.CreateError(System.String,System.Object[])">
            <summary>  Creates failure result </summary>
            <param name="errorFormatString">format string for the error message</param>
            <param name="args">The arguments.</param>
            <returns>result that is a failure</returns>
            <exception cref="T:System.ArgumentNullException">if format string is null</exception>
        </member>
        <member name="M:Netco.Monads.Result`1.CreateSuccess(`0)">
            <summary>
            Creates the success result.
            </summary>
            <param name="value">The value.</param>
            <returns>result encapsulating the success value</returns>
            <exception cref="T:System.ArgumentNullException">if value is a null reference type</exception>
        </member>
        <member name="M:Netco.Monads.Result`1.Convert``1(System.Func{`0,``0})">
            <summary>
            Converts value of this instance
            using the provided <paramref name="converter"/>
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The converter.</param>
            <returns>Converted result</returns>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="converter"/> is null</exception>
        </member>
        <member name="M:Netco.Monads.Result`1.CreateError(System.String)">
            <summary>
            Creates the error result.
            </summary>
            <param name="error">The error.</param>
            <returns>result encapsulating the error value</returns>
            <exception cref="T:System.ArgumentNullException">if error is null</exception>
        </member>
        <member name="M:Netco.Monads.Result`1.op_Implicit(`0)~Netco.Monads.Result{`0}">
            <summary>
            Performs an implicit conversion from <typeparamref name="T"/> to <see cref="T:Netco.Monads.Result`1"/>.
            </summary>
            <param name="value">The item.</param>
            <returns>The result of the conversion.</returns>
            <exception cref="T:System.ArgumentNullException">if <paramref name="value"/> is a reference type that is null</exception>
        </member>
        <member name="M:Netco.Monads.Result`1.Combine``1(System.Func{`0,Netco.Monads.Result{``0}})">
            <summary>
            Combines this <see cref="T:Netco.Monads.Result`1"/> with the result returned
            by <paramref name="converter"/>.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The converter.</param>
            <returns>Combined result.</returns>
        </member>
        <member name="M:Netco.Monads.Result`1.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Netco.Monads.Result`1.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Netco.Monads.Result`1.Equals(Netco.Monads.Result{`0})">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Netco.Monads.Result`1.Apply(System.Action{`0})">
            <summary>
            Applies the specified <paramref name="action"/>
            to this <see cref="T:Netco.Monads.Result`1"/>, if it has value.
            </summary>
            <param name="action">The action to apply.</param>
            <returns>returns same instance for inlining</returns>
            <exception cref="T:System.ArgumentNullException">if <paramref name="action"/> is null</exception>
        </member>
        <member name="M:Netco.Monads.Result`1.Handle(System.Action{System.String})">
            <summary>
            Handles the specified handler.
            </summary>
            <param name="handler">The handler.</param>
            <returns>same instance for the inlining</returns>
        </member>
        <member name="M:Netco.Monads.Result`1.ToMaybe``1(System.Func{`0,``0})">
            <summary>
            Converts this <see cref="T:Netco.Monads.Result`1"/> to <see cref="T:Netco.Monads.Maybe`1"/>, 
            using the <paramref name="converter"/> to perform the value conversion.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The reflector.</param>
            <returns><see cref="T:Netco.Monads.Maybe`1"/> that represents the original value behind the <see cref="T:Netco.Monads.Result`1"/> after the conversion</returns>
        </member>
        <member name="M:Netco.Monads.Result`1.ToMaybe">
            <summary>
            Converts this <see cref="T:Netco.Monads.Result`1"/> to <see cref="T:Netco.Monads.Maybe`1"/>, 
            with the original value reference, if there is any.
            </summary>
            <returns><see cref="T:Netco.Monads.Maybe`1"/> that represents the original value behind the <see cref="T:Netco.Monads.Result`1"/>.</returns>
        </member>
        <member name="M:Netco.Monads.Result`1.ExposeException(System.Func{System.String,System.Exception})">
            <summary>
            Exposes result failure as the exception (providing compatibility, with the exception -expecting code).
            </summary>
            <param name="exception">The function to generate exception, provided the error string.</param>
            <returns>result value</returns>
        </member>
        <member name="M:Netco.Monads.Result`1.op_Implicit(System.String)~Netco.Monads.Result{`0}">
            <summary>
            Performs an implicit conversion from <see cref="T:System.String"/> to <see cref="T:Netco.Monads.Result`1"/>.
            </summary>
            <param name="error">The error.</param>
            <returns>The result of the conversion.</returns>
            <exception cref="T:System.ArgumentNullException">If value is a null reference type</exception>
        </member>
        <member name="M:Netco.Monads.Result`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Netco.Monads.Result`1.ErrorMessage">
            <summary>
            Error message associated with this failure
            </summary>
        </member>
        <member name="P:Netco.Monads.Result`1.IsSuccess">
            <summary>
            Gets a value indicating whether this result is valid.
            </summary>
            <value><c>true</c> if this result is valid; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Netco.Monads.Result`1.Value">
            <summary>
            item associated with this result
            </summary>
        </member>
        <member name="P:Netco.Monads.Result`1.Error">
            <summary>
            Error message associated with this failure
            </summary>
        </member>
        <member name="T:Netco.Monads.Result`2">
            <summary>
            Improved version of the Result[T], that could serve as a basis for it.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <typeparam name="TError">The type of the error.</typeparam>
            <remarks>It is to be moved up-stream if found useful in other projects.</remarks>
        </member>
        <member name="M:Netco.Monads.Result`2.CreateSuccess(`0)">
            <summary>
            Creates the success result.
            </summary>
            <param name="value">The value.</param>
            <returns>result encapsulating the success value</returns>
            <exception cref="T:System.ArgumentNullException">if value is a null reference type</exception>
        </member>
        <member name="M:Netco.Monads.Result`2.CreateError(`1)">
            <summary>
            Creates the error result.
            </summary>
            <param name="error">The error.</param>
            <returns>result encapsulating the error value</returns>
            <exception cref="T:System.ArgumentNullException">if error is a null reference type</exception>
        </member>
        <member name="M:Netco.Monads.Result`2.op_Implicit(`0)~Netco.Monads.Result{`0,`1}">
            <summary>
            Performs an implicit conversion from <typeparamref name="TValue"/> to <see cref="T:Netco.Monads.Result`2"/>.
            </summary>
            <param name="value">The value.</param>
            <returns>The result of the conversion.</returns>
            <exception cref="T:System.ArgumentNullException">If value is a null reference type</exception>
        </member>
        <member name="M:Netco.Monads.Result`2.op_Implicit(`1)~Netco.Monads.Result{`0,`1}">
            <summary>
            Performs an implicit conversion from <typeparamref name="TError"/> to <see cref="T:Netco.Monads.Result`2"/>.
            </summary>
            <param name="error">The error.</param>
            <returns>The result of the conversion.</returns>
            <exception cref="T:System.ArgumentNullException">If value is a null reference type</exception>
        </member>
        <member name="M:Netco.Monads.Result`2.Equals(Netco.Monads.Result{`0,`1})">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:Netco.Monads.Result`2.Apply(System.Action{`0})">
            <summary>
            Applies the specified <paramref name="action"/>
            to this <see cref="T:Netco.Monads.Result`1"/>, if it has value.
            </summary>
            <param name="action">The action to apply.</param>
            <returns>returns same instance for inlining</returns>
            <exception cref="T:System.ArgumentNullException">if <paramref name="action"/> is null</exception>
        </member>
        <member name="M:Netco.Monads.Result`2.Handle(System.Action{`1})">
            <summary>
            Handles the specified handler.
            </summary>
            <param name="handler">The handler.</param>
            <returns>same instance for the inlining</returns>
        </member>
        <member name="M:Netco.Monads.Result`2.Convert``1(System.Func{`0,``0})">
            <summary>
            Converts value of this instance
            using the provided <paramref name="converter"/>
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The converter.</param>
            <returns>Converted result</returns>
            <exception cref="T:System.ArgumentNullException"> if <paramref name="converter"/> is null</exception>
        </member>
        <member name="M:Netco.Monads.Result`2.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>.</param>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <exception cref="T:System.NullReferenceException">
            The <paramref name="obj"/> parameter is null.
            </exception>
        </member>
        <member name="M:Netco.Monads.Result`2.GetHashCode">
            <summary>
            Serves as a hash function for a particular type.
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:Netco.Monads.Result`2.Combine``1(System.Func{`0,Netco.Monads.Result{``0,`1}})">
            <summary>
            Combines this <see cref="T:Netco.Monads.Result`1"/> with the result returned
            by <paramref name="converter"/>.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The converter.</param>
            <returns>Combined result.</returns>
        </member>
        <member name="M:Netco.Monads.Result`2.ToMaybe``1(System.Func{`0,``0})">
            <summary>
            Converts this <see cref="T:Netco.Monads.Result`1"/> to <see cref="T:Netco.Monads.Maybe`1"/>, 
            using the <paramref name="converter"/> to perform the value conversion.
            </summary>
            <typeparam name="TTarget">The type of the target.</typeparam>
            <param name="converter">The reflector.</param>
            <returns><see cref="T:Netco.Monads.Maybe`1"/> that represents the original value behind the <see cref="T:Netco.Monads.Result`1"/> after the conversion</returns>
        </member>
        <member name="M:Netco.Monads.Result`2.ToMaybe">
            <summary>
            Converts this <see cref="T:Netco.Monads.Result`1"/> to <see cref="T:Netco.Monads.Maybe`1"/>, 
            with the original value reference, if there is any.
            </summary>
            <returns><see cref="T:Netco.Monads.Maybe`1"/> that represents the original value behind the <see cref="T:Netco.Monads.Result`1"/>.</returns>
        </member>
        <member name="M:Netco.Monads.Result`2.ExposeException(System.Func{`1,System.Exception})">
            <summary>
            Exposes result failure as the exception (providing compatibility, with the exception -expecting code).
            </summary>
            <param name="exception">The function to generate exception, provided the error string.</param>
            <returns>result value</returns>
        </member>
        <member name="M:Netco.Monads.Result`2.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Netco.Monads.Result`2.Value">
            <summary>
            item associated with this result
            </summary>
        </member>
        <member name="P:Netco.Monads.Result`2.Error">
            <summary>
            Error message associated with this failure
            </summary>
        </member>
        <member name="P:Netco.Monads.Result`2.IsSuccess">
            <summary>
            Gets a value indicating whether this result is valid.
            </summary>
            <value><c>true</c> if this result is valid; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:Netco.Monads.Result">
            <summary> Helper class for creating <see cref="T:Netco.Monads.Result`1"/> instances </summary>
        </member>
        <member name="M:Netco.Monads.Result.CreateSuccess``1(``0)">
            <summary> Creates success result </summary>
            <typeparam name="TValue">The type of the result.</typeparam>
            <param name="value">The item.</param>
            <returns>new result instance</returns>
            <seealso cref="M:Netco.Monads.Result`1.CreateSuccess(`0)"/>
        </member>
        <member name="M:Netco.Monads.Result.Success``1(``0)">
            <summary> Creates success result </summary>
            <typeparam name="TValue">The type of the result.</typeparam>
            <param name="value">The item.</param>
            <returns>new result instance</returns>
            <seealso cref="M:Netco.Monads.Result`1.CreateSuccess(`0)"/>
        </member>
        <member name="T:Netco.Monads.Walk">
            <summary>
            Simplifies acessing a chain of properties when one of the property can be null. Instead of exception thrown <c>null</c> is still returned.
            </summary>
            <example>
            string code = licensePlate.MaybeDeep( lp => lp.Car.Owner.Address.PostCode );
            </example>
            <remarks>There's an overhead associated with dynamic unwrapping of accessing members into expressions.
            Avoid this for high performance sections.</remarks>
            <seealso href = "http://maybe.codeplex.com" />
            <seealso href = "http://blogs.msdn.com/alexj/archive/2008/03/03/maybe-there-is-more.aspx" />
            <seealso href = "http://blogs.developpeur.org/miiitch/archive/2008/02/29/vendredi-c-est-expression-tree.aspx" />
        </member>
        <member name="M:Netco.Monads.Walk.IsNullable(System.Type)">
            <summary>
            Check the type to see if it's Nullable.
            </summary>
            <param name = "theType">Type to check.</param>
            <returns><c>true</c> if type is Nullable, <c>false</c> otherwise.</returns>
            <see href="http://davidhayden.com/blog/dave/archive/2006/11/26/IsTypeNullableTypeConverter.aspx"/>
        </member>
        <member name="F:Netco.Monads.Walk._maybeNullableMethod">
            <summary>
            	For types that return a nullable
            </summary>
        </member>
        <member name="M:Netco.Monads.Walk.MaybeShallowNullable``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Wraps properties access that results in a nullable types
            </summary>
            <typeparam name = "TSource">Source type.</typeparam>
            <typeparam name = "TResult">Nullable result type</typeparam>
            <param name = "source">Source data.</param>
            <param name = "expression">Expression to access properties.</param>
            <returns>Nullable result experession.</returns>
        </member>
        <member name="M:Netco.Monads.Walk.MaybeShallowPrimitive``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Wrapes properties shallow access for expression that returns nullable type.
            </summary>
            <typeparam name = "TSource">Source type.</typeparam>
            <typeparam name = "TResult">Nullable result type.</typeparam>
            <param name = "source">Source data.</param>
            <param name = "expression">Shallow {source.Property} access expression.</param>
            <returns>Result in nullable type.</returns>
        </member>
        <member name="M:Netco.Monads.Walk.MaybeDeepToNullable``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``1,``2})">
            <summary>
            Wraps deep access to <paramref name="source"/> properties.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <typeparam name="TCurry">The type of the curry.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="source">The source.</param>
            <param name="expression">The expression.</param>
            <param name="finalAccessor">The final accessor.</param>
            <returns>Results of using <paramref name="finalAccessor"/> acting on result of <paramref name="expression"/>.</returns>
        </member>
        <member name="M:Netco.Monads.Walk.MaybeDeep``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            	Goes as deep as the expression so x.MaybeDeep&lt;Z,X>( x=>x.y.z)
            </summary>
            <typeparam name = "TSource"></typeparam>
            <typeparam name = "TResult"></typeparam>
            <param name = "t"></param>
            <param name = "ex"></param>
            <returns></returns>
            <seealso href="http://blogs.developpeur.org/miiitch/archive/2008/02/29/vendredi-c-est-expression-tree.aspx"/>
        </member>
        <member name="M:Netco.Monads.Walk.MaybeShallow``2(``0,System.Func{``0,``1})">
            <summary>
            	Only goes one level in so x.MaybeShawllow(x=>x.y)
            </summary>
            <typeparam name = "T"></typeparam>
            <typeparam name = "TV"></typeparam>
            <param name = "t"></param>
            <param name = "selector"></param>
            <returns></returns>
        </member>
        <member name="M:Netco.Monads.Walk.ConvertMemberToMethodCall(System.Linq.Expressions.MemberExpression)">
            <summary>
            	This method converts a call from a member in method call. Basically:
            	'. MaProp' becomes '. Maybe (p => p.MaProp)'
            </summary>
            <param name = "memberExpression"></param>
            <returns></returns>
        </member>
        <member name="T:Netco.Net.PostSubmitter">
            <summary>
            Submits post data to a url.
            </summary>
            <seealso href="http://geekswithblogs.net/rakker/archive/2006/04/21/76044.aspx"/>
            <example>Example on how to POST
            <code>
            PostSubmitter post=new PostSubmitter();
            post.Url="http://seeker.dice.com/jobsearch/servlet/JobSearch";
            post.PostItems.Add("op","100");
            post.PostItems.Add("rel_code","1102");
            post.PostItems.Add("FREE_TEXT","c# jobs");
            post.PostItems.Add("SEARCH","");
            post.Type=PostSubmitter.PostTypeEnum.Post;
            string result=post.Post();</code></example>
        </member>
        <member name="M:Netco.Net.PostSubmitter.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Netco.Net.PostSubmitter.#ctor(System.String)">
            <summary>
            Constructor that accepts a url as a parameter
            </summary>
            <param name="url">The url where the post will be submitted to.</param>
        </member>
        <member name="M:Netco.Net.PostSubmitter.#ctor(System.String,System.Collections.Specialized.NameValueCollection)">
            <summary>
            Constructor allowing the setting of the url and items to post.
            </summary>
            <param name="url">the url for the post.</param>
            <param name="values">The values for the post.</param>
        </member>
        <member name="M:Netco.Net.PostSubmitter.Post">
            <summary>
            Posts the supplied data to specified url.
            </summary>
            <returns>a string containing the result of the post.</returns>
        </member>
        <member name="M:Netco.Net.PostSubmitter.Post(System.String)">
            <summary>
            Posts the supplied data to specified url.
            </summary>
            <param name="url">The url to post to.</param>
            <returns>a string containing the result of the post.</returns>
        </member>
        <member name="M:Netco.Net.PostSubmitter.Post(System.String,System.Collections.Specialized.NameValueCollection)">
            <summary>
            Posts the supplied data to specified url.
            </summary>
            <param name="url">The url to post to.</param>
            <param name="values">The values to post.</param>
            <returns>a string containing the result of the post.</returns>
        </member>
        <member name="M:Netco.Net.PostSubmitter.PostData(System.String,System.String)">
            <summary>
            Posts data to a specified url. Note: this assumes that you have already url encoded the post data.
            </summary>
            <param name="postData">The data to post.</param>
            <param name="url">the url to post to.</param>
            <returns>Returns the result of the post.</returns>
        </member>
        <member name="M:Netco.Net.PostSubmitter.BeginPost">
            <summary>
            Posts the supplied data to specified url using async methods.
            </summary>
        </member>
        <member name="M:Netco.Net.PostSubmitter.BeginPost(System.String)">
            <summary>
            Posts the supplied data to specified url using async methods.
            </summary>
            <param name="url">The url to post to.</param>
        </member>
        <member name="M:Netco.Net.PostSubmitter.BeginPost(System.String,System.Collections.Specialized.NameValueCollection)">
            <summary>
            Posts the supplied data to specified url using async methods.
            </summary>
            <param name="url">The url to post to.</param>
            <param name="values">The values to post.</param>
        </member>
        <member name="M:Netco.Net.PostSubmitter.PostDataAsync(System.String,System.String)">
            <summary>
            Posts data to a specified <paramref name="url"/>.
            </summary>
            <remarks>Assumes that you have already <paramref name="url"/> encoded the post data</remarks>
            <param name="postData">The data to post.</param>
            <param name="url">The <c>url</c> to post to.</param>
        </member>
        <member name="M:Netco.Net.PostSubmitter.GetParameters">
            <summary>
            Gets parameters string.
            </summary>
            <returns>All parameters encoded in a single string.</returns>
        </member>
        <member name="M:Netco.Net.PostSubmitter.EncodeAndAddItem(System.Text.StringBuilder@,System.String,System.String)">
            <summary>
            Encodes an item and ads it to the string.
            </summary>
            <param name="baseRequest">The previously encoded data.</param>
            <param name="key">Param key.</param>
            <param name="dataItem">The data to encode.</param>
            <returns>A string containing the old data and the previously encoded data.</returns>
        </member>
        <member name="M:Netco.Net.PostSubmitter.SetTimeout(System.Nullable{System.TimeSpan},System.Action{System.Int32})">
            <summary>
            Sets the timeout.
            </summary>
            <param name="timeout">The timeout.</param>
            <param name="methodToSetTimout">The method to set timout.</param>
        </member>
        <member name="P:Netco.Net.PostSubmitter.IgnoreErrors">
            <summary>
            Gets or sets a value indicating whether to ignore errors, or throw exception.
            </summary>
            <value><c>true</c> if errors should be ignored; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Netco.Net.PostSubmitter.Timeout">
            <summary>
            Gets or sets the request timeout.
            </summary>
            <value>The request timeout.</value>
            <remarks><see cref="F:System.TimeSpan.MaxValue"/> indicates infinite timeout (never timeouts).</remarks>
        </member>
        <member name="P:Netco.Net.PostSubmitter.ReadWriteTimeout">
            <summary>
            Gets or sets the read/write timeout.
            </summary>
            <value>The read/write timeout.</value>
            <remarks><see cref="F:System.TimeSpan.MaxValue"/> indicates infinite timeout (never timeouts).</remarks>
        </member>
        <member name="P:Netco.Net.PostSubmitter.Url">
            <summary>
            Gets or sets the url to submit the post to.
            </summary>
        </member>
        <member name="P:Netco.Net.PostSubmitter.PostItems">
            <summary>
            Gets or sets the name value collection of items to post.
            </summary>
        </member>
        <member name="P:Netco.Net.PostSubmitter.Type">
            <summary>
            Gets or sets the type of action to perform against the url.
            </summary>
        </member>
        <member name="E:Netco.Net.PostSubmitter.AsyncPostFinished">
            <summary>
            Raised when asynchronous post is finished.
            </summary>
        </member>
        <member name="T:Netco.Net.PostSubmitter.PostTypeEnum">
            <summary>
            determines what type of post to perform.
            </summary>
        </member>
        <member name="F:Netco.Net.PostSubmitter.PostTypeEnum.Get">
            <summary>
            Does a get against the source.
            </summary>
        </member>
        <member name="F:Netco.Net.PostSubmitter.PostTypeEnum.Post">
            <summary>
            Does a post against the source.
            </summary>
        </member>
        <member name="T:Netco.Net.PostSubmitter.AsyncPostFinishedEventArgs">
            <summary>
            Event arguments for <see cref="E:Netco.Net.PostSubmitter.AsyncPostFinished"/>
            </summary>
        </member>
        <member name="P:Netco.Net.PostSubmitter.AsyncPostFinishedEventArgs.Result">
            <summary>Gets the result of asynchronous post.</summary>
        </member>
        <member name="T:Netco.Profiling.Profiler">
            <summary>
            Time and memory profiling.
            </summary>
            <remarks>Profiling works through a stack. <see cref="M:Netco.Profiling.Profiler.Start(System.String)"/> saves current time
            and starts profiling. <see cref="M:Netco.Profiling.Profiler.End"/> stops profiling and logs current results.
            <see cref="M:Netco.Profiling.Profiler.End"/> must be called in reverse from <see cref="M:Netco.Profiling.Profiler.Start(System.String)"/> order.</remarks>
        </member>
        <member name="M:Netco.Profiling.Profiler.Start(System.String)">
            <summary>
            Starts profiler.
            </summary>
            <param name="name">The name of the profile.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="name"/> is null or empty.</exception>
        </member>
        <member name="M:Netco.Profiling.Profiler.End">
            <summary>
            Ends profiling.
            </summary>
            <returns><see cref="T:Netco.Profiling.ProfilingInfo"/> holding info about the current profiling.</returns>
            <remarks>Logs time profiler ran and memory used delta.</remarks>
        </member>
        <member name="M:Netco.Profiling.Profiler.End(System.String)">
            <summary>
            Ends profiling with the specified message.
            </summary>
            <param name="message">The message.</param>
            <returns><see cref="T:Netco.Profiling.ProfilingInfo"/> holding info about the current profiling.</returns>
            <remarks>Logs time profiler ran and memory used delta.</remarks>
        </member>
        <member name="M:Netco.Profiling.Profiler.GetCurrentMemory">
            <summary>
            Gets the current used memory.
            </summary>
            <returns>Bytes allocated to the current process.</returns>
        </member>
        <member name="M:Netco.Profiling.Profiler.GetCurrentMemoryInMB">
            <summary>
            Gets the current memory in MB.
            </summary>
            <returns>Megabytes allocated to the current process.</returns>
        </member>
        <member name="M:Netco.Profiling.Profiler.GetCurrentMemoryGC">
            <summary>
            Gets the current memory thought to be allocated by GC.
            </summary>
            <returns>Bytes allocated by GC.</returns>
            <seealso cref="M:System.GC.GetTotalMemory(System.Boolean)"/>
        </member>
        <member name="M:Netco.Profiling.Profiler.GetCurrentMemoryGCInMB">
            <summary>
            Gets the current memory thought to be allocated by GC in MB.
            </summary>
            <returns>Megabytes allocated by GC.</returns>
            <seealso cref="M:System.GC.GetTotalMemory(System.Boolean)"/>
        </member>
        <member name="P:Netco.Profiling.Profiler.EnableProfiling">
            <summary>
            Gets or sets a value indicating whether profiling is enabled.
            </summary>
            <value><c>true</c> to enable profiling; otherwise, <c>false</c>.</value>
            <remarks>By default profiling is enabled.
            <para>This affects prevents profiling from getting started. If any profiling is
            taking place it will be ended regardless what this property value is.</para></remarks>
        </member>
        <member name="P:Netco.Profiling.Profiler.EnableLogging">
            <summary>
            Gets or sets a value indicating whether to log profiling results.
            </summary>
            <value><c>true</c> to log results; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Netco.Profiling.Profiler.Logger">
            <summary>
            Gets or sets the logger.
            </summary>
            <value>The logger.</value>
        </member>
        <member name="T:Netco.Profiling.ProfilingInfo">
            <summary>
            Holds profiling information.
            </summary>
        </member>
        <member name="P:Netco.Profiling.ProfilingInfo.StartTime">
            <summary>
            Gets the profiling start time.
            </summary>
            <value>The profiling start time.</value>
        </member>
        <member name="P:Netco.Profiling.ProfilingInfo.StartMemory">
            <summary>
            Gets the profiling start memory.
            </summary>
            <value>The profiling start memory.</value>
        </member>
        <member name="P:Netco.Profiling.ProfilingInfo.EndTime">
            <summary>
            Gets the profiling end time.
            </summary>
            <value>The profiling end time.</value>
        </member>
        <member name="P:Netco.Profiling.ProfilingInfo.EndMemory">
            <summary>
            Gets the profiling end memory.
            </summary>
            <value>The profiling end memory.</value>
        </member>
        <member name="P:Netco.Profiling.ProfilingInfo.Duration">
            <summary>
            Gets the profiling span.
            </summary>
            <value>The profiling span.</value>
        </member>
        <member name="P:Netco.Profiling.ProfilingInfo.MemoryDelta">
            <summary>
            Gets the memory delta.
            </summary>
            <value>The memory delta.</value>
        </member>
        <member name="P:Netco.Profiling.ProfilingInfo.Name">
            <summary>
            Gets the profiling name.
            </summary>
            <value>The profiling name.</value>
        </member>
        <member name="T:Netco.Syntaxis.Syntax`1">
            <summary>
            Helper class for creating fluent APIs
            </summary>
            <typeparam name="TTarget">underlying type</typeparam>
        </member>
        <member name="M:Netco.Syntaxis.Syntax`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Netco.Syntaxis.Syntax`1"/> class.
            </summary>
            <param name="inner">The underlying instance.</param>
        </member>
        <member name="P:Netco.Syntaxis.Syntax`1.Target">
            <summary>
            Gets the underlying object.
            </summary>
            <value>The underlying object.</value>
        </member>
        <member name="T:Netco.Threading.ReaderWriterLockSlimExtensions">
            <summary>
            Helper class that simplifies <see cref="T:System.Threading.ReaderWriterLockSlim"/> usage
            </summary>
        </member>
        <member name="M:Netco.Threading.ReaderWriterLockSlimExtensions.GetReadLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Gets the read lock object, that is released when the object is disposed.
            </summary>
            <param name="slimLock">The slim lock object.</param>
            <returns></returns>
        </member>
        <member name="M:Netco.Threading.ReaderWriterLockSlimExtensions.GetWriteLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Gets the write lock, that is released when the object is disposed.
            </summary>
            <param name="slimLock">The slim lock.</param>
            <returns></returns>
        </member>
        <member name="M:Netco.Threading.ReaderWriterLockSlimExtensions.GetUpgradeableReadLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Gets the upgradeable read lock, that is released, when the object is disposed
            </summary>
            <param name="slimLock">The slim lock.</param>
            <returns></returns>
        </member>
        <member name="T:Netco.Threading.WaitFor`1">
            <summary>
            Helper class for invoking tasks with timeout. Overhead is 0,005 ms.
            </summary>
            <typeparam name="TResult">The type of the result.</typeparam>
        </member>
        <member name="M:Netco.Threading.WaitFor`1.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Netco.Threading.WaitFor`1"/> class, 
            using the specified timeout for all operations.
            </summary>
            <param name="timeout">The timeout.</param>
        </member>
        <member name="M:Netco.Threading.WaitFor`1.Run(System.Func{`0})">
            <summary>
            Executes the specified function within the current thread, aborting it
            if it does not complete within the specified timeout interval. 
            </summary>
            <param name="function">The function.</param>
            <returns>result of the function</returns>
            <remarks>
            The performance trick is that we do not interrupt the current
            running thread. Instead, we just create a watcher that will sleep
            until the originating thread terminates or until the timeout is
            elapsed.
            </remarks>
            <exception cref="T:System.ArgumentNullException">if function is null</exception>
            <exception cref="T:System.TimeoutException">if the function does not finish in time </exception>
        </member>
        <member name="M:Netco.Threading.WaitFor`1.Run(System.TimeSpan,System.Func{`0})">
            <summary>
            Executes the specified function within the current thread, aborting it
            if it does not complete within the specified timeout interval.
            </summary>
            <param name="timeout">The timeout.</param>
            <param name="function">The function.</param>
            <returns>result of the function</returns>
            <remarks>
            The performance trick is that we do not interrupt the current
            running thread. Instead, we just create a watcher that will sleep
            until the originating thread terminates or until the timeout is
            elapsed.
            </remarks>
            <exception cref="T:System.ArgumentNullException">if function is null</exception>
            <exception cref="T:System.TimeoutException">if the function does not finish in time </exception>
        </member>
        <member name="T:Netco.Utils.EnumComparer`1">
            <summary>
            A fast and efficient implementation of <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> for Enum types.
            Useful for dictionaries that use Enums as their keys. 
            </summary>
            <remarks>
            http://www.codeproject.com/KB/cs/EnumComparer.aspx
            </remarks>
            <example>
            <code>
            var dict = new Dictionary&lt;DayOfWeek, string&gt;(EnumComparer&lt;DayOfWeek&gt;.Instance);
            </code>
            </example>
            <typeparam name="TEnum">The type of the Enum.</typeparam>
        </member>
        <member name="F:Netco.Utils.EnumComparer`1.Instance">
            <summary>
            The singleton accessor.
            </summary>
        </member>
        <member name="M:Netco.Utils.EnumComparer`1.#cctor">
            <summary>
            Initializes the <see cref="T:Netco.Utils.EnumComparer`1"/> class
            by generating the GetHashCode and Equals methods.
            </summary>
        </member>
        <member name="M:Netco.Utils.EnumComparer`1.#ctor">
            <summary>
            A private constructor to prevent user instantiation.
            </summary>
        </member>
        <member name="M:Netco.Utils.EnumComparer`1.Equals(`0,`0)">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            <param name="x">The first object of type <typeparamref name="TEnum"/> to compare.</param>
            <param name="y">The second object of type <typeparamref name="TEnum"/> to compare.</param>
            <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
        </member>
        <member name="M:Netco.Utils.EnumComparer`1.GetHashCode(`0)">
            <summary>
            Returns a hash code for the specified object.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> for which a hash code is to be returned.</param>
            <returns>A hash code for the specified object.</returns>
            <exception cref="T:System.ArgumentNullException">
            The type of <paramref name="obj"/> is a reference type and <paramref name="obj"/> is null.
            </exception>
        </member>
        <member name="M:Netco.Utils.EnumComparer`1.GenerateEquals">
            <summary>
            Generates a comparison method similiar to this:
            <code>
            bool Equals(TEnum x, TEnum y)
            {
                return x == y;
            }
            </code>
            </summary>
            <returns>The generated method.</returns>
        </member>
        <member name="M:Netco.Utils.EnumComparer`1.GenerateGetHashCode">
            <summary>
            Generates a GetHashCode method similar to this:
            <code>
            int GetHashCode(TEnum obj)
            {
                return ((int)obj).GetHashCode();
            }
            </code>
            </summary>
            <returns>The generated method.</returns>
        </member>
        <member name="T:Netco.Utils.EnumUtil">
            <summary>
            Enum helper class from xLim
            </summary>
        </member>
        <member name="M:Netco.Utils.EnumUtil.Parse``1(System.String)">
            <summary>
            Parses the specified string into the <typeparamref name="TEnum"/>, ignoring the case
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="value">The value.</param>
            <returns>Parsed enum</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="value"/> is null</exception>
        </member>
        <member name="M:Netco.Utils.EnumUtil.Parse``1(System.String,System.Boolean)">
            <summary>
            Parses the specified string into the <typeparamref name="TEnum"/>, ignoring the case
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="value">The value.</param>
            <param name="ignoreCase">if set to <c>true</c> [ignore case].</param>
            <returns>Parsed enum</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="value"/> is null</exception>
        </member>
        <member name="M:Netco.Utils.EnumUtil.ToIdentifier``1(``0)">
            <summary>
            Unwraps the enum by creating a string usable for identifiers and resource lookups.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <param name="enumItem">The enum item.</param>
            <returns>a string usable for identifiers and resource lookups</returns>
        </member>
        <member name="M:Netco.Utils.EnumUtil.GetValues``1">
            <summary>
            Gets the values associated with the specified enum.
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <returns>array instance of the enum values</returns>
        </member>
        <member name="M:Netco.Utils.EnumUtil.GetValuesWithoutDefault``1">
            <summary>
            Gets the values associated with the specified enum, 
            with the exception of the default value
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
            <returns>array instance of the enum values</returns>
        </member>
        <member name="T:Netco.Utils.EnumUtil`1">
            <summary>
            Strongly-typed enumeration util
            </summary>
            <typeparam name="TEnum">The type of the enum.</typeparam>
        </member>
        <member name="F:Netco.Utils.EnumUtil`1.Values">
            <summary>
            Values of the <typeparamref name="TEnum"/>
            </summary>
        </member>
        <member name="F:Netco.Utils.EnumUtil`1.ValuesWithoutDefault">
            <summary>
            Values of the <typeparamref name="TEnum"/> without the default value.
            </summary>
        </member>
        <member name="F:Netco.Utils.EnumUtil`1.Comparer">
            <summary>
            Efficient comparer for the enum
            </summary>
        </member>
        <member name="M:Netco.Utils.EnumUtil`1.ConvertSafelyFrom``1(``0)">
            <summary>
            Converts the specified enum safely from the target enum. Matching is done
            via the efficient <see cref="F:Netco.Utils.EnumUtil`1.Comparer"/> initialized with <see cref="M:Netco.Monads.MaybeParse.Enum``1(System.String)"/>
            </summary>
            <typeparam name="TSourceEnum">The type of the source enum.</typeparam>
            <param name="enum">The @enum to convert from.</param>
            <returns>converted enum</returns>
            <exception cref="T:System.ArgumentException"> when conversion is not possible</exception>
        </member>
        <member name="T:Netco.Utils.EnumUtil`2">
            <summary>
            Ensures that enums can be converted between each other
            </summary>
            <typeparam name="TFromEnum">The type of from enum.</typeparam>
            <typeparam name="TToEnum">The type of to enum.</typeparam>
        </member>
        <member name="T:Netco.Utils.SystemUtil">
            <summary>
            System utils to improve testability of the code
            </summary>
        </member>
        <member name="F:Netco.Utils.SystemUtil.SleepAction">
            <summary>
            <see cref="M:System.Threading.Thread.Sleep(System.TimeSpan)"/>
            </summary>
        </member>
        <member name="F:Netco.Utils.SystemUtil.DateTimeProvider">
            <summary>
            Allows to set custom date time implementation for the testing purposes.
            </summary>
        </member>
        <member name="M:Netco.Utils.SystemUtil.Reset">
            <summary>
            Returns all overridable functions to default. To be used by test teardowns
            </summary>
        </member>
        <member name="M:Netco.Utils.SystemUtil.SetSleep(System.Action{System.TimeSpan})">
            <summary>
            Sets the custom sleep routine.
            </summary>
            <param name="sleepRoutine">The sleep routine.</param>
        </member>
        <member name="M:Netco.Utils.SystemUtil.SetDateTimeProvider(System.Func{System.DateTime})">
            <summary>
            Sets the custom date time provider routine.
            </summary>
            <param name="dateTimeProvider">The date time provider.</param>
        </member>
        <member name="M:Netco.Utils.SystemUtil.SetTime(System.DateTime)">
            <summary>
            Shortcut to set the custom date time.
            </summary>
            <param name="time">The time.</param>
        </member>
        <member name="M:Netco.Utils.SystemUtil.Sleep(System.TimeSpan)">
            <summary>
            Invokes the method associated with sleeping. For the production purposes
            this should be a call to <see cref="M:System.Threading.Thread.Sleep(System.TimeSpan)"/>
            </summary>
            <param name="span">The span.</param>
        </member>
        <member name="P:Netco.Utils.SystemUtil.Now">
            <summary>
            <see cref="P:System.DateTime.Now"/>
            </summary>
        </member>
        <member name="P:Netco.Utils.SystemUtil.UtcNow">
            <summary>
            <see cref="P:System.DateTime.UtcNow"/>
            </summary>
        </member>
        <member name="P:Netco.Utils.SystemUtil.NowOffset">
            <summary>
            Unambiguous date and time with UTC offset, <see cref="P:System.DateTimeOffset.Now"/>.
            </summary>
        </member>
        <member name="T:Netco.WCF.ClientLoggingEndpointBehavior">
            <summary>
            Connection point to WCF to provide logging behavior.
            </summary>
        </member>
        <member name="M:Netco.WCF.ClientLoggingEndpointBehavior.Validate(System.ServiceModel.Description.ServiceEndpoint)">
            <summary>Implement to confirm that the endpoint meets some intended criteria.</summary>
            <param name="endpoint">The endpoint to validate.</param>
        </member>
        <member name="M:Netco.WCF.ClientLoggingEndpointBehavior.AddBindingParameters(System.ServiceModel.Description.ServiceEndpoint,System.ServiceModel.Channels.BindingParameterCollection)">
            <summary>Implement to pass data at runtime to bindings to support custom behavior.</summary>
            <param name="endpoint">The endpoint to modify.</param>
            <param name="bindingParameters">The objects that binding elements require to support the behavior.</param>
        </member>
        <member name="M:Netco.WCF.ClientLoggingEndpointBehavior.ApplyDispatchBehavior(System.ServiceModel.Description.ServiceEndpoint,System.ServiceModel.Dispatcher.EndpointDispatcher)">
            <summary>Implements a modification or extension of the service across an endpoint.</summary>
            <param name="endpoint">The endpoint that exposes the contract.</param>
            <param name="endpointDispatcher">The endpoint dispatcher to be modified or extended.</param>
        </member>
        <member name="M:Netco.WCF.ClientLoggingEndpointBehavior.ApplyClientBehavior(System.ServiceModel.Description.ServiceEndpoint,System.ServiceModel.Dispatcher.ClientRuntime)">
            <summary>Implements a modification or extension of the client across an endpoint.</summary>
            <param name="endpoint">The endpoint that is to be customized.</param>
            <param name="clientRuntime">The client runtime to be customized.</param>
        </member>
        <member name="T:Netco.WCF.ClientLoggingBehaviorExtensionElement">
            <summary>
            Connection point for logging behavior.
            </summary>
            <example>
            Configuration example for app.config (insert into basicHttpBinding)
            <code>
            <![CDATA[
            <client>
            	<endpoint address="http://serviceURL" 
            		binding="basicHttpBinding" 
            		bindingConfiguration="serviceConfig" 
            		contract="serviceContract"     
            		name="serviceName"
            		behaviorConfiguration="loggingEndpointBehavior" />
            </client>
            <extensions>
            	<behaviorExtensions>
            		<add name="clientLogging" type="Netco.WCF.ClientLoggingBehaviorExtensionElement, Netco"/>
            	</behaviorExtensions>
            </extensions>
            <behaviors>
            	<endpointBehaviors>
            		<behavior name="loggingEndpointBehavior">
            			<clientLogging />
            		</behavior>
            	</endpointBehaviors>
            </behaviors>
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Netco.WCF.ClientLoggingBehaviorExtensionElement.CreateBehavior">
            <summary>Creates a behavior extension based on the current configuration settings.</summary>
            <returns>The behavior extension.</returns>
        </member>
        <member name="P:Netco.WCF.ClientLoggingBehaviorExtensionElement.BehaviorType">
            <summary>Gets the type of behavior.</summary>
            <returns>A <see cref="T:System.Type"/>.</returns>
        </member>
        <member name="T:Netco.WCF.LoggingInspector">
            <summary>
            Inspects WCF messages and logs them into trace channel.
            </summary>
        </member>
        <member name="M:Netco.WCF.LoggingInspector.BeforeSendRequest(System.ServiceModel.Channels.Message@,System.ServiceModel.IClientChannel)">
            <summary>Enables inspection or modification of a message before a request message is sent to a service.</summary>
            <param name="request">The message to be sent to the service.</param>
            <param name="channel">The  client object channel.</param>
            <returns>
            The object that is returned as the <c>correlationState</c> argument of the <see cref="M:System.ServiceModel.Dispatcher.IClientMessageInspector.AfterReceiveReply(System.ServiceModel.Channels.Message@,System.Object)"/> method. This is null if no correlation state is used.The best practice is to make this a <see cref="T:System.Guid"/> to ensure that no two <c>correlationState</c> objects are the same.
            </returns>
        </member>
        <member name="M:Netco.WCF.LoggingInspector.AfterReceiveReply(System.ServiceModel.Channels.Message@,System.Object)">
            <summary>
            Enables inspection or modification of a message after a reply message is received but prior to passing it back to the client application.
            </summary>
            <param name="reply">The message to be transformed into types and handed back to the client application.</param>
            <param name="correlationState">Correlation state data.</param>
        </member>
    </members>
</doc>
